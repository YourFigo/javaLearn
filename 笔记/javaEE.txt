XML
	Extensible Markup Language 可扩展标记语言。可扩展的意思是 标签都是自定义的。
	特点：
		1. xml文档的后缀名 .xml
		2. xml第一行必须定义为文档声明
		3. xml文档中有且仅有一个根标签
		4. 属性值必须使用引号(单双都可)引起来
		5. 标签必须正确关闭
		6. xml标签名称区分大小写
	一个入门例子：
		<?xml version='1.0' ?>
		<users>
			<user id='1'>
				<name>zhangsan</name>
				<age>23</age>
				<gender>male</gender>
				<br/>
			</user>
			
			<user id='2'>
				<name>lisi</name>
				<age>24</age>
				<gender>female</gender>
			</user>
		</users>
	其他注意：	
		1、文档声明
			格式：<?xml 属性列表 ?>
			属性列表：
				version：版本号，必须的属性
				encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1
				standalone：是否独立
					取值：
						* yes：不依赖其他文件
						* no：依赖其他文件
		2、标签中的id属性值唯一
		3、CDATA区：在该区域中的数据会被原样展示
			格式：  <![CDATA[ 数据 ]]>
	约束：规定xml文档的书写规则，有两种常见的约束：
		1. DTD:一种简单的约束技术，文件后缀为 .dtd
		2. Schema:一种复杂的约束技术，Schema虽然比DTD复杂，但它可以限定标签体中数据的取值，文件后缀为 .xsd，Schema文件本身也就是一个xml文档
	解析xml：
		1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树
			* 优点：操作方便，可以对文档进行CRUD的所有操作
			* 缺点：占内存
		2. SAX：逐行读取，基于事件驱动的。
			* 优点：不占内存。
			* 缺点：只能读取，不能增删改
		这里我们使用一种DOM方式的解析库：Jsoup
			//2.1获取student.xml的path
			String path = JsoupDemo1.class.getClassLoader().getResource("student.xml").getPath();
			//2.2解析xml文档，加载文档进内存，获取dom树--->Document
			Document document = Jsoup.parse(new File(path), "utf-8");
			//3.获取元素对象 Element
			Elements elements = document.getElementsByTag("name");
	
			System.out.println(elements.size());
			//3.1获取第一个name的Element对象
			Element element = elements.get(0);
			//3.2获取数据
			String name = element.text();
			System.out.println(name);
		Jsoup中的对象：
			1. Jsoup：工具类，可以解析html或xml文档，返回Document
				* parse：解析html或xml文档，返回Document
					parse​(File in, String charsetName)：解析xml或html文件的。
					parse​(String html)：解析xml或html字符串
					parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象
			2. Document：文档对象。代表内存中的dom树
				* 获取Element对象
					getElementById​(String id)：根据id属性值获取唯一的element对象
					getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
					getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
					getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合
			3. Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用
			4. Element：元素对象
				1. 获取子元素对象
					getElementById​(String id)：根据id属性值获取唯一的element对象
					getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
					getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
					getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合

				2. 获取属性值
					String attr(String key)：根据属性名称获取属性值
				3. 获取文本内容
					String text():获取文本内容
					String html():获取标签体的所有内容(包括字标签的字符串内容)
			5. Node：节点对象
				是Document和Element的父类
		快速查询xml文档中的内容的方式：
			1. selector:选择器
				* 使用的方法：Elements	select​(String cssQuery)
					* 语法：参考Jsoup中Selector类中定义的语法
			2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言
				* 使用Jsoup的Xpath需要额外导入jar包。
				* 查询w3cshool参考手册，使用xpath的语法完成查询

Servlet
	idea中的project相对于eclipse中的workspace的概念，因此先创建一个project然后在这个project中创建一个module，相对于就是一个具体的web项目了。
	Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。
	步骤
		1创建JavaEE项目
		2. 定义一个类，实现Servlet接口
			* public class ServletDemo1 implements Servlet
		3. 实现接口中的抽象方法
		4. 在web.xml中配置Servlet
			<servlet>
				<servlet-name>demo1</servlet-name>
				<servlet-class>cn.figo.web.ServletDemo</servlet-class>
			</servlet>
			<servlet-mapping>
				<servlet-name>demo1</servlet-name>
				<url-pattern>/demo1</url-pattern>
			</servlet-mapping>
	执行原理：
		1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径
		2. 查找web.xml文件，是否有对应的<url-pattern>标签体内容。
		3. 如果有，则在找到对应的<servlet-class>全类名
		4. tomcat会将字节码文件加载进内存，并且创建其对象
		5. 调用其中的方法
	Servlet中方法的生命周期
		init方法，Servlet被创建时调用一次，默认情况下，第一次被访问时创建Servlet
			也可以在<servlet>标签下配置，在服务器启动时，创建Servlet
			<load-on-startup>的值为负数：第一次被访问时，Servlet被创建
			<load-on-startup>的值为0或正整数：在服务器启动时，创建Servlet
			Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
		service方法：
			每次访问Servlet时，Service方法都会被调用一次。
		destroy方法：
			服务器关闭时，Servlet被销毁时执行 destroy方法，只执行一次。
			只有服务器正常关闭时，才会执行destroy方法。
	注意：
		Servlet的版本3.0以上，可以不创建web.xml，在类上使用@WebServlet注解，进行配置。
		@WebServlet("资源路径")
		urlpartten:Servlet访问路径
			1. 一个Servlet可以定义多个访问路径 ： @WebServlet({"/d4","/dd4","/ddd4"})
			2. 路径定义规则：
				/xxx：路径匹配
				/xxx/xxx:多层路径，目录结构
				*.do：扩展名匹配
		java中WebServlet这个注解的定义为：
			@Target({ElementType.TYPE})
			@Retention(RetentionPolicy.RUNTIME)
			@Documented
			public @interface WebServlet {
				String name() default "";//相当于<Servlet-name>
			
				String[] value() default {};//代表urlPatterns()属性配置
			
				String[] urlPatterns() default {};//相当于<url-pattern>
			
				int loadOnStartup() default -1;//相当于<load-on-startup>
			
				WebInitParam[] initParams() default {};
			
				boolean asyncSupported() default false;
			
				String smallIcon() default "";
			
				String largeIcon() default "";
			
				String description() default "";
			
				String displayName() default "";
			}
	GenericServlet ：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象
		* 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可
		一般不使用 GenericServlet
	HttpServlet：对http协议的一种封装，简化操作
		1. 定义类继承HttpServlet
		2. 复写doGet/doPost方法
	HTTP协议：Hyper Text Transfer Protocol 超文本传输协议
		协议版本：
			1.0：每一次请求响应都会建立新的连接，消耗资源
			1.1：复用连接，节省资源
		特点：
			1. 基于TCP/IP的高级协议
			2. 默认端口号:80
			3. 基于请求/响应模型的:一次请求对应一次响应
			4. 无状态的：每次请求之间相互独立，不能交互数据
		请求消息数据格式：
			请求行：(请求方式 请求url 请求协议/版本)
				GET /login.html	HTTP/1.1
				请求方式：
					HTTP协议有7中请求方式，常用的有2种
					GET：
						1. 请求参数在请求行中，在url后。
						2. 请求的url长度有限制的
						3. 不太安全
					POST：
						1. 请求参数在请求体中
						2. 请求的url长度没有限制的
						3. 相对安全
			请求头：客户端浏览器告诉服务器一些信息
				1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息
					* 可以在服务器端获取该头的信息，解决浏览器的兼容性问题
				2. Referer：http://localhost/login.html
					* 告诉服务器，我(当前请求)从哪里来
					Refere的应用：1. 防盗链 2. 统计工作：
			请求空行
				空行，就是用于分割POST请求的请求头，和请求体的。
			请求体(正文)：
				封装POST请求消息的请求参数的
			一个请求例子(是字符串格式的)：
				POST /login.html	HTTP/1.1
				Host: localhost
				User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
				Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
				Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
				Accept-Encoding: gzip, deflate
				Referer: http://localhost/login.html
				Connection: keep-alive
				Upgrade-Insecure-Requests: 1
				
				username=zhangsan

request
	ServletRequest --(继承)-->	HttpServletRequest --(实现)-->	org.apache.catalina.connector.RequestFacade 类
	通过request可以获取请求消息数据
		一：获取请求行数据:
			对于请求行： GET /day14/demo1?name=zhangsan HTTP/1.1
			1. 获取请求方式 ：GET
				String getMethod()  
			2. (*)获取虚拟目录：/day14
				String getContextPath()
			3. 获取Servlet路径: /demo1
				String getServletPath()
			4. 获取get方式请求参数：name=zhangsan
				String getQueryString()
			5. (*)获取请求URI：/day14/demo1
				String getRequestURI():		/day14/demo1
				StringBuffer getRequestURL()  :http://localhost/day14/demo1
				URL:统一资源定位符 ： http://localhost/day14/demo1
				URI：统一资源标识符 : /day14/demo1
			6. 获取协议及版本：HTTP/1.1
				String getProtocol()
			7. 获取客户机的IP地址：
				String getRemoteAddr()
		二：获取请求头数据:
			(*)String getHeader(String name):通过请求头的名称获取请求头的值
			Enumeration<String> getHeaderNames():获取所有的请求头名称
		三：获取请求体数据:
			请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
			1. 获取流对象
				BufferedReader getReader()：获取字符输入流，只能操作字符数据
				ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据
			2. 再从流对象中拿数据
		四：其他功能
			获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数
				1. String getParameter(String name):根据参数名称获取参数值    username=zs&password=123
				2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&hobby=game
				3. Enumeration<String> getParameterNames():获取所有请求的参数名称
				4. Map<String,String[]> getParameterMap():获取所有参数的map集合
			请求转发：一种在服务器内部的资源跳转方式
				特点：
				浏览器地址栏路径不发生变化
				只能转发到当前服务器内部资源中。
				转发是一次请求
				步骤：
				1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)
				2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)
			共享数据
				域对象：一个有作用范围的对象，可以在范围内共享数据
				request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据
				1. void setAttribute(String name,Object obj):存储数据
				2. Object getAttitude(String name):通过键获取值
				3. void removeAttribute(String name):通过键移除键值对
			获取ServletContext：
				ServletContext getServletContext()
		BeanUtils工具类，简化数据封装，用于封装JavaBean
			JavaBean：标准的Java类
			要求：
				1. 类必须被public修饰
				2. 必须提供空参的构造器
				3. 成员变量必须使用private修饰
				4. 提供公共setter和getter方法
			成员变量：类中定义的成员变量
			属性：setter和getter方法截取后的产物
				例如：getUsername() --> Username--> username
			工具类中的方法：（要求JavaBean中的get、set方法命名规范）
				1. setProperty()
				2. getProperty()
				3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中
				
	例子：
		页面：http://localhost:8080/servlet_learn/form.html
		<!DOCTYPE html>
		<html lang="en">
		<head>
			<meta charset="UTF-8">
			<title>post</title>
		</head>
		<body>
			<form action="/servlet_learn/requestDemo1" method="get">
				<input type="text" name="user"/>
				<br>
				<input type="checkbox" name="like" value="game">游戏
				<input type="checkbox" name="like" value="study">学习
				<br>
				<input type="submit" value="提交">
			</form>
		</body>
		</html>
		
		// HttpServlet
		package cn.figo.web.request;

		import javax.servlet.ServletException;
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.BufferedReader;
		import java.io.IOException;
		import java.util.Enumeration;
		import java.util.Map;
		import java.util.Set;

		@WebServlet("/requestDemo1")
		public class RequestDemo1 extends HttpServlet {
			protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

				// 请求体，只有post方式有
				//获取字符输入流，只能操作字符数据
				// user=lisi&btn=%E6%8F%90%E4%BA%A4
				BufferedReader br = request.getReader();
				String line = null;
				while ((line = br.readLine()) != null){
					System.out.println(line);
				}
				//获取字节输入流，可以操作所有类型数据
				// ServletInputStream getInputStream()


			}

			protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				// 请求行
				// GET /requestDemo1?user=shangsan&btn=%E6%8F%90%E4%BA%A4 HTTP/1.1
				// GET /servlet_learn/requestDemo1?user=lisi&btn=%E6%8F%90%E4%BA%A4 HTTP/1.1
				System.out.println(request.getMethod());  // GET
				System.out.println(request.getContextPath());
				// 第一次tomcat中配置为/因此为空；第二次配置为/servlet_learn，结果为 /servlet_learn
				System.out.println(request.getServletPath()); // /requestDemo1
				System.out.println(request.getQueryString()); // user=shangsan&btn=%E6%8F%90%E4%BA%A4
				System.out.println(request.getRequestURI());  // /requestDemo1
				System.out.println(request.getRequestURL());  // http://localhost:8080/requestDemo1
				System.out.println(request.getProtocol());    // HTTP/1.1
				System.out.println(request.getRemoteAddr());  // 0:0:0:0:0:0:0:1

				// 请求头
				Enumeration<String> headerNames = request.getHeaderNames();
				System.out.println(headerNames);
				while (headerNames.hasMoreElements()){
					String headerName = headerNames.nextElement();
					String value = request.getHeader(headerName);
					System.out.println(headerName + ": " + value);
				}

				System.out.println("-----------------------------");
				String userValue = request.getParameter("user");
				System.out.println(userValue);
				System.out.println("-----------------------------");
				String[] likeValues = request.getParameterValues("like");
				for (String likeValue : likeValues) {
					System.out.println(likeValue);
				}

				System.out.println("-----------------------------");
				Enumeration<String> paraNames = request.getParameterNames();
				while (paraNames.hasMoreElements()){
					String paraName = paraNames.nextElement();
					String paraValue = request.getParameter(paraName);
					// String[] paraValue = request.getParameterValues(paraName);
					System.out.println(paraName + ": " + paraValue);
				}

				System.out.println("-------------------------------");
				Map<String,String[]> paraMap = request.getParameterMap();
				Set<String> keySet = paraMap.keySet();
				for (String name :keySet){
					System.out.println(name);
					String[] values = paraMap.get(name);
					System.out.println(values);
					for (String value : values){
						System.out.println(value);
					}
					System.out.println("============");
				}

			}
		}
		
		输出：
			GET
			/servlet_learn
			/requestDemo1
			user=lisi&like=game&like=study
			/servlet_learn/requestDemo1
			http://localhost:8080/servlet_learn/requestDemo1
			HTTP/1.1
			0:0:0:0:0:0:0:1
			org.apache.tomcat.util.http.NamesEnumerator@57206aaf
			host: localhost:8080
			connection: keep-alive
			upgrade-insecure-requests: 1
			user-agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36
			sec-fetch-mode: navigate
			sec-fetch-user: ?1
			accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
			sec-fetch-site: same-origin
			referer: http://localhost:8080/servlet_learn/form.html
			accept-encoding: gzip, deflate, br
			accept-language: zh-CN,zh;q=0.9
			cookie: JSESSIONID=63D658A1F557F36FEA8C97A6D6AF6B8C; _ga=GA1.1.1778445080.1563089064; csrftoken=ZnWKg5ZuuSYd3dwts5iqnfjQvSnp21n9OiuFZAKz11WdGZuXENLhAxYckiLHFTsI
			-----------------------------
			lisi
			-----------------------------
			game
			study
			-----------------------------
			user: lisi
			like: game
			-------------------------------
			user
			[Ljava.lang.String;@25f76ac0
			lisi
			============
			like
			[Ljava.lang.String;@12bedba3
			game
			study
			============
	
	一个例子：在页面输入用户名和密码，进行权限判断。
		登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您；登录失败跳转到FailServlet展示：登录失败，用户名或密码错误。
		使用Druid数据库连接池技术,操作mysql，使用spring的JdbcTemplate技术封装JDBC。
		
		//首先编写实体类 User
		package cn.figo.web.domain;

		/**
		 * 数据库中的user表的实体类
		 */
		public class User {
			private int id;
			private String username;
			private String password;

			public int getId() {
				return id;
			}

			public void setId(int id) {
				this.id = id;
			}

			public String getUsername() {
				return username;
			}

			public void setUsername(String username) {
				this.username = username;
			}

			public String getPassword() {
				return password;
			}

			public void setPassword(String password) {
				this.password = password;
			}

			@Override
			public String toString() {
				return "User{" +
						"id=" + id +
						", username='" + username + '\'' +
						", password='" + password + '\'' +
						'}';
			}
		}
		
		//然后编写通用工具类 JDBCUtils
		package cn.figo.web.util;

		import com.alibaba.druid.pool.DruidDataSourceFactory;

		import javax.sql.DataSource;
		import java.io.IOException;
		import java.io.InputStream;
		import java.sql.Connection;
		import java.sql.SQLException;
		import java.util.Properties;

		public class JDBCUtils {
			private static DataSource ds;

			//静态代码块用来加载配置文件，初始化连接池对象
			static {
				try {
					Properties pro = new Properties();
					InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");
					pro.load(is);
					ds = DruidDataSourceFactory.createDataSource(pro);
				} catch (IOException e) {
					e.printStackTrace();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

			/**
			 * 获取连接池对象
			 * @return
			 */
			public static DataSource getDataSource(){
				return ds;
			}

			/**
			 * 获取连接对象
			 * @return
			 * @throws SQLException
			 */
			public static Connection getConnection() throws SQLException {
				return ds.getConnection();
			}
		}

		//然后编写操作数据库表的 UserDao
		package cn.figo.web.dao;

		import cn.figo.web.domain.User;
		import cn.figo.web.util.JDBCUtils;
		import org.springframework.dao.DataAccessException;
		import org.springframework.jdbc.core.BeanPropertyRowMapper;
		import org.springframework.jdbc.core.JdbcTemplate;

		/**
		 * 操作数据库中的user表
		 */
		public class UserDao {
			//声明 JDBCTemplate对象 共用
			private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());

			/**
			 * 登录方法
			 * @param loginUser 只有用户名和密码
			 * @return user包含用户的所有数据
			 */
			public User login(User loginUser){

				try {
					String sql = "select * from user where username = ? and password = ?";
					User user = template.queryForObject(sql,
							new BeanPropertyRowMapper<User>(User.class),
							loginUser.getUsername(),loginUser.getPassword());
					return user;
				} catch (DataAccessException e) {
					e.printStackTrace();
					return null;
				}
			}
		}

		//现在编写一个测试类，测试UserDao中登录方法是否有效
		package cn.figo.web.test;

		import cn.figo.web.dao.UserDao;
		import cn.figo.web.domain.User;
		import org.junit.Test;

		public class UserDaoTest {

			@Test
			public void testLogin(){

				User loginUser = new User();
				loginUser.setUsername("zhangsan");
				loginUser.setPassword("123456");
				UserDao dao = new UserDao();
				User user = dao.login(loginUser);
				System.out.println(user);
			}
		}
		
		//然后编写 LoginServlet 用于请求处理、判断和转发
		package cn.figo.web.servlet;

		import cn.figo.web.dao.UserDao;
		import cn.figo.web.domain.User;
		import org.apache.commons.beanutils.BeanUtils;

		import javax.servlet.ServletException;
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.IOException;
		import java.lang.reflect.InvocationTargetException;
		import java.util.Map;

		@WebServlet("/LoginServlet")
		public class LoginServlet extends HttpServlet {
			@Override
			protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
				req.setCharacterEncoding("utf-8");
				/*
				//获取请求参数
				String username = req.getParameter("username");
				String password = req.getParameter("password");
				//封装User对象
				User loginUser = new User();
				loginUser.setUsername(username);
				loginUser.setPassword(password);
				 */

				//使用开源的beanutils简化对象的封装
				Map<String,String[]> map = req.getParameterMap();
				User loginUser = new User();
				try {
					BeanUtils.populate(loginUser,map);
				} catch (IllegalAccessException e) {
					e.printStackTrace();
				} catch (InvocationTargetException e) {
					e.printStackTrace();
				}

				UserDao dao = new UserDao();
				User user = dao.login(loginUser);

				//如果登录成功，转发到成功页，否则转发到失败页
				if (user == null){
					req.getRequestDispatcher("/failServlet").forward(req,resp);
				}else {
					req.setAttribute("user",user);
					req.getRequestDispatcher("/successServlet").forward(req,resp);
				}
			}

			@Override
			protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
				super.doPut(req, resp);
			}
		}

		// SuccessServlet
		package cn.figo.web.servlet;

		import cn.figo.web.domain.User;

		import javax.servlet.ServletException;
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.IOException;

		@WebServlet("/successServlet")
		public class SuccessServlet extends HttpServlet {
			protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

				User user = (User) request.getAttribute("user");
				if (user != null){
					response.setContentType("text/html;charset=utf-8");
					response.getWriter().write("登录成功，" + user.getUsername() + "欢迎您");
				}
			}

			protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

				this.doPost(request,response);
			}
		}

		// failServlet
		package cn.figo.web.servlet;

		import javax.servlet.ServletException;
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.IOException;

		@WebServlet("/failServlet")
		public class FailServlet extends HttpServlet {
			protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

				response.setContentType("text/html;charset=utf-8");
				response.getWriter().write("登录失败，用户名或密码错误");
			}

			protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

				this.doPost(request,response);
			}
		}

response
	HTTP响应消息
		1. 响应行
		组成：协议/版本 响应状态码 状态码描述
		响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。
			状态码都是3位数字 
			分类：
				1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码
				2xx：成功。代表：200
				3xx：重定向。代表：302(重定向)，304(访问缓存)
				4xx：客户端错误。
				* 404（请求路径没有对应的资源） 
				* 405：请求方式没有对应的doXxx方法
				5xx：服务器端错误。代表：500(服务器内部出现异常)	
		2. 响应头：
		格式：头名称： 值
		常见的响应头：
			Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式
			Content-disposition：服务器告诉客户端以什么格式打开响应体数据
			值：
				in-line:默认值,在当前页面内打开
				attachment;filename=xxx：以附件形式打开响应体。文件下载
		3. 响应空行
		4. 响应体:传输的数据
	
	一个完整的响应字符串：
		HTTP/1.1 200 OK
		Content-Type: text/html;charset=UTF-8
		Content-Length: 101
		Date: Wed, 06 Jun 2018 07:08:42 GMT

		<html>
		  <head>
			<title>$Title$</title>
		  </head>
		  <body>
		  hello , response
		  </body>
		</html>
	
	设置状态码：setStatus(int sc) 
	设置响应头：setHeader(String name, String value) 
	设置响应体：
		// 解决乱码
		response.setContentType("text/html;charset=utf-8");
		1. 获取输出流
			字符输出流：PrintWriter getWriter()
			字节输出流：ServletOutputStream getOutputStream()
		2. 使用输出流，将数据输出到客户端浏览器
	
	//ResponseDemo1
	package cn.figo.web.response;

	import javax.servlet.ServletException;
	import javax.servlet.annotation.WebServlet;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import java.io.IOException;

	@WebServlet("/ResponseDemo1")
	public class ResponseDemo1 extends HttpServlet {
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			System.out.println("ResponseDemo1 1111111111");

			request.setAttribute("msg","hello");
			// 重定向
			//response.setStatus(302);
			//response.setHeader("location","/servlet_learn/ResponseDemo2");

			//简单重定向
			//response.sendRedirect("/servlet_learn/ResponseDemo2");
			//重定向可以重定向到其他站点
			//response.sendRedirect("https://www.baidu.com/");
			//这个是绝对路径，实际路径为http://localhost:8080/ResponseDemo2，
			// 但是ResponseDemo2的真实路径为 http://localhost:8080/servlet_learn/ResponseDemo2
			//response.sendRedirect("/ResponseDemo2");  //访问失败
			// 可以使用相对路径
			//response.sendRedirect("./ResponseDemo2");

			// 请求转发 可以使用 request域共享数据
			request.getRequestDispatcher("/ResponseDemo2").forward(request,response);
			// 转发就不需要加虚拟目录，给服务器用不需要加虚拟路径，给浏览器用需要加虚拟目录，
			// 因为重定向浏览器地址栏要变，因此必须加虚拟目录

		}

		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

			this.doPost(request,response);
		}
	}
	
	// /ResponseDemo2
	package cn.figo.web.response;

	import javax.servlet.ServletException;
	import javax.servlet.ServletOutputStream;
	import javax.servlet.annotation.WebServlet;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import java.io.IOException;
	import java.io.PrintWriter;

	@WebServlet("/ResponseDemo2")
	public class ResponseDemo2 extends HttpServlet {
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

			System.out.println("ResponseDemo2 2222222222");
			//重定向是两次请求。不能使用request对象来共享数据
			Object msg = request.getAttribute("msg");
			System.out.println(msg);

			//再请求转发回ResponseDemo1，会造成死循环，浏览器提示重定向次数过多
			//request.getRequestDispatcher("/ResponseDemo1").forward(request,response);

			//  服务器输出字节数据到浏览器
			//简单的形式，设置编码
			response.setContentType("text/html;charset=utf-8");
			//1.获取字符输出流
			//PrintWriter pw = response.getWriter();
			//2.输出数据
			//pw.write("<h1>hello response</h1>");
			//pw.write("你好啊啊啊 response");

			//1.获取字节输出流
			ServletOutputStream sos = response.getOutputStream();
			//2.输出数据
			sos.write("你好".getBytes("utf-8"));
		}

		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

			this.doPost(request,response);
		}
	}

	
ServletContext对象：代表整个web应用，可以和程序的容器(服务器)来通信
	获取该对象有两种方式：
		通过request对象获取
			request.getServletContext();
		通过HttpServlet获取
			this.getServletContext();
	获取MIME类型：
		MIME类型:在互联网通信过程中定义的一种文件数据类型
			格式： 大类型/小类型   text/html
		String getMimeType(String file)
	共享数据
		setAttribute(String name,Object value)
		getAttribute(String name)
		removeAttribute(String name)
		ServletContext对象范围：所有用户所有请求的数据
	获取文件的真实(服务器)路径
		String getRealPath(String path)
	
	// ServletContentDemo1
	package cn.figo.web.servletContent;

	import javax.servlet.ServletContext;
	import javax.servlet.ServletException;
	import javax.servlet.ServletOutputStream;
	import javax.servlet.annotation.WebServlet;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import java.io.IOException;
	import java.io.PrintWriter;

	@WebServlet("/ServletContentDemo1")
	public class ServletContentDemo1 extends HttpServlet {
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

			//1. 通过request对象获取
			ServletContext context1 = request.getServletContext();
			//2. 通过HttpServlet获取
			ServletContext context2 = this.getServletContext();

			System.out.println(context1);
			System.out.println(context2);

			System.out.println(context1 == context2);//true

			//3. 定义文件名称
			String filename = "a.jpg";//image/jpeg
			//4.获取MIME类型
			String mimeType = context2.getMimeType(filename);
			System.out.println(mimeType);

			// 获取文件的服务器路径
			String b = context2.getRealPath("/b.txt");//web目录下资源访问
			System.out.println(b);

			//设置数据
			context2.setAttribute("msg","haha");
			//获取数据
			Object msg = context1.getAttribute("msg");
			System.out.println(msg);
		}

		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

			this.doPost(request,response);
		}
	}

	实现文件下载
	1. 页面显示超链接
	2. 点击超链接后弹出下载提示框
	3. 完成图片文件下载
		package cn.figo.web.servlet;

		import cn.figo.web.util.DownLoadUtils;
		import javax.servlet.ServletContext;
		import javax.servlet.ServletException;
		import javax.servlet.ServletOutputStream;
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.FileInputStream;
		import java.io.IOException;

		@WebServlet("/downloadServlet")
		public class DownloadServlet extends HttpServlet {
			protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				//1.获取请求参数，文件名称
				String filename = request.getParameter("filename");
				//2.使用字节输入流加载文件进内存
				//2.1找到文件服务器路径
				ServletContext servletContext = this.getServletContext();
				String realPath = servletContext.getRealPath("/img/" + filename);
				//2.2用字节流关联
				FileInputStream fis = new FileInputStream(realPath);

				//3.设置response的响应头
				//3.1设置响应头类型：content-type
				String mimeType = servletContext.getMimeType(filename);//获取文件的mime类型
				response.setHeader("content-type",mimeType);
				//3.2设置响应头打开方式:content-disposition

				//解决中文文件名问题
				//1.获取user-agent请求头、
				String agent = request.getHeader("user-agent");
				//2.使用工具类方法编码文件名即可
				filename = DownLoadUtils.getFileName(agent, filename);

				response.setHeader("content-disposition","attachment;filename="+filename);
				//4.将输入流的数据写出到输出流中
				ServletOutputStream sos = response.getOutputStream();
				byte[] buff = new byte[1024 * 8];
				int len = 0;
				while((len = fis.read(buff)) != -1){
					sos.write(buff,0,len);
				}

				fis.close();


			}

			protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				this.doPost(request,response);
			}
		}
		
		
		package cn.figo.web.util;

		import java.io.UnsupportedEncodingException;
		import java.net.URLEncoder;


		public class DownLoadUtils {

			public static String getFileName(String agent, String filename) throws UnsupportedEncodingException {
				if (agent.contains("MSIE")) {
					// IE浏览器
					filename = URLEncoder.encode(filename, "utf-8");
					filename = filename.replace("+", " ");
				} else {
					// 其它浏览器
					filename = URLEncoder.encode(filename, "utf-8");
				}
				return filename;
			}
		}
	
	
会话技术
1. 会话：一次会话中包含多次请求和响应。
	一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止
2. 功能：在一次会话的范围内的多次请求间，共享数据
3. 方式：
	客户端会话技术：Cookie
	服务器端会话技术：Session

Cookie：客户端会话技术，将数据保存到客户端
	使用步骤：
	1. 创建Cookie对象，绑定数据
		new Cookie(String name,String value) 
	2. 发送Cookie对象
		response.addCookie(Cookie cookie) 
	3. 获取Cookie，拿到数据
		Cookie[]  request.getCookies() 
	实现原理
		基于响应头set-cookie和请求头cookie实现，请求头中有Cookie这个请求头。
	cookie的一些问题
	1. 一次可不可以发送多个cookie?
		可以
		可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。
	2. cookie在浏览器中保存多长时间？
		默认情况下，当浏览器关闭后，Cookie数据被销毁
		持久化存储：
			setMaxAge(int seconds)
			正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效
			负数：默认值
			零：删除cookie信息
	3. cookie能不能存中文？
		在tomcat 8 之前cookie中不能直接存储中文数据。需要将中文数据转码---一般采用URL编码(%E3)
		在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析
	4. cookie共享问题？
	假设在一个tomcat服务器中，部署了多个web项目，默认情况下cookie不能共享，可以使用
	setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录，如果要共享，则可以将path设置为"/"		
	不同的tomcat服务器间cookie共享，使用
		setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享
		setDomain(".baidu.com"),那么tieba.baidu.com和news.baidu.com中cookie可以共享
	5. Cookie的特点和作用
	特点
	cookie存储数据在客户端浏览器
	浏览器对于单个cookie 的大小有限制(4kb)以及对同一个域名下的总cookie数量也有限制(20个)
	作用：
	cookie一般用于存出少量的不太敏感的数据
	在不登录的情况下，完成服务器对客户端的身份识别
	
	//cookie的一个例子
	package cn.figo.web.servlet;

	import javax.servlet.ServletException;
	import javax.servlet.annotation.WebServlet;
	import javax.servlet.http.Cookie;
	import javax.servlet.http.HttpServlet;
	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletResponse;
	import java.io.IOException;
	import java.net.URLDecoder;
	import java.net.URLEncoder;
	import java.text.SimpleDateFormat;
	import java.util.Date;

	/**
	 *  访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。
	 * 	如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串
	 */
	@WebServlet("/CookieTest")
	public class CookieTest extends HttpServlet {
		protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			//有中文，设置响应的消息体的数据格式以及编码
			response.setContentType("text/html;charset=utf-8");
			//获取所有Cookie
			Cookie[] cookies = request.getCookies();
			boolean flag = false;
			//如果有cookie
			if (cookies != null && cookies.length > 0){
				//遍历cookie数组
				for (Cookie cookie : cookies){
					//获取cookie的名称
					String name = cookie.getName();
					//判断名称是否是：lastTime,有该Cookie，不是第一次访问
					if("lastTime".equals(name)){
						flag = true;

						//先从cookie中获取上次登录时间
						String value = cookie.getValue();
						System.out.println("解码前： " + value);
						value = URLDecoder.decode(value,"utf-8");
						System.out.println("解码后： " + value);
						response.getWriter().write("欢迎回来，您上次的访问时间为： " + value);

						//在获取当前时间来更新cookie的值
						Date date = new Date();
						SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
						String str_date = sdf.format(date);
						System.out.println("编码前： " + str_date);
						str_date = URLEncoder.encode(str_date,"utf-8");
						System.out.println("编码后： " + str_date);

						cookie.setValue(str_date);
						cookie.setMaxAge(60 * 60 * 24 * 30);
						response.addCookie(cookie);

					}
				}
			}
			if (cookies == null || cookies.length == 0 || flag == false){
				//第一次访问，设置Cookie的value
				Date date = new Date();
				SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
				String str_date = sdf.format(date);
				System.out.println("编码前： " + str_date);
				str_date = URLEncoder.encode(str_date,"utf-8");
				System.out.println("编码后： " + str_date);

				Cookie cookie = new Cookie("lastTime",str_date);
				cookie.setValue(str_date);
				cookie.setMaxAge(60 * 60 * 24 * 30);
				response.addCookie(cookie);
				response.getWriter().write("您好，欢迎您首次访问");
			}
		}

		protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

			this.doPost(request,response);
		}
	}

Session：
	服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。Session的实现是依赖于Cookie的。
	HttpSession
		1. 获取HttpSession对象：
	HttpSession session = request.getSession();
		2. 使用HttpSession对象：
	Object getAttribute(String name) 
	void setAttribute(String name,Object value)
	void removeAttribute(String name) 
	一些问题
	1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？
		默认情况下。不是。
		如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。
	Cookie c = new Cookie("JSESSIONID",session.getId());
	c.setMaxAge(60*60);
	response.addCookie(c);
	2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？
		不是同一个，但是要确保数据不丢失。tomcat自动完成钝化和活化。
		session的钝化：在服务器正常关闭之前，将session对象系列化到硬盘上
		session的活化：在服务器启动后，将session文件转化为内存中的session对象		
	3. session什么时候被销毁？
		服务器关闭时，session对象调用invalidate()。
		session默认失效时间为30分钟
		可以修改配置	
	<session-config>
			<session-timeout>30</session-timeout>
	</session-config>

	session的特点
		1. session用于存储一次会话的多次请求的数据，存在服务器端
		2. session可以存储任意类型，任意大小的数据

	session与Cookie的区别：
		1. session存储数据在服务器端，Cookie在客户端
		2. session没有数据大小限制，Cookie有
		3. session数据安全，Cookie相对于不安全

	实现带验证码的登录
		package cn.figo.web.servlet;

		import javax.servlet.ServletException;
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import javax.servlet.http.HttpSession;
		import java.io.IOException;

		@WebServlet("/loginCheckServlet")
		public class LoginCheckServlet extends HttpServlet {
			protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				//1.设置request编码
				request.setCharacterEncoding("utf-8");
				//2.获取参数
				String username = request.getParameter("username");
				String password = request.getParameter("password");
				String checkCode = request.getParameter("checkCode");
				//3.先获取生成的验证码
				HttpSession session = request.getSession();
				String checkCode_session = (String) session.getAttribute("checkCode_session");
				//删除session中存储的验证码
				session.removeAttribute("checkCode_session");
				//3.先判断验证码是否正确
				if(checkCode_session!= null && checkCode_session.equalsIgnoreCase(checkCode)){
					//忽略大小写比较
					//验证码正确
					//判断用户名和密码是否一致
					if("zhangsan".equals(username) && "123".equals(password)){//需要调用UserDao查询数据库
						//登录成功
						//存储信息，用户信息
						session.setAttribute("user",username);
						//重定向到success.jsp
						response.sendRedirect(request.getContextPath()+"/success.jsp");
					}else{
						//登录失败
						//存储提示信息到request
						request.setAttribute("login_error","用户名或密码错误");
						//转发到登录页面
						request.getRequestDispatcher("/login.jsp").forward(request,response);
					}


				}else{
					//验证码不一致
					//存储提示信息到request
					request.setAttribute("cc_error","验证码错误");
					//转发到登录页面
					request.getRequestDispatcher("/login.jsp").forward(request,response);

				}

			}

			protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				this.doPost(request, response);
			}
		}
		
		
		package cn.figo.web.servlet;

		import javax.imageio.ImageIO;
		import javax.servlet.ServletException;
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.awt.*;
		import java.awt.image.BufferedImage;
		import java.io.IOException;
		import java.util.Random;

		@WebServlet("/loginCheckCodeServlet")
		public class LoginCheckCodeServlet extends HttpServlet {
			protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {


				int width = 100;
				int height = 50;

				//1.创建一对象，在内存中图片(验证码图片对象)
				BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);


				//2.美化图片
				//2.1 填充背景色
				Graphics g = image.getGraphics();//画笔对象
				g.setColor(Color.PINK);//设置画笔颜色
				g.fillRect(0,0,width,height);

				//2.2画边框
				g.setColor(Color.BLUE);
				g.drawRect(0,0,width - 1,height - 1);

				String str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789";
				//生成随机角标
				Random ran = new Random();
				StringBuilder sb = new StringBuilder();
				for (int i = 1; i <= 4; i++) {
					int index = ran.nextInt(str.length());
					//获取字符
					char ch = str.charAt(index);//随机字符
					sb.append(ch);

					//2.3写验证码
					g.drawString(ch+"",width/5*i,height/2);
				}
				String checkCode_session = sb.toString();
				//将验证码存入session
				request.getSession().setAttribute("checkCode_session",checkCode_session);

				//2.4画干扰线
				g.setColor(Color.GREEN);

				//随机生成坐标点

				for (int i = 0; i < 10; i++) {
					int x1 = ran.nextInt(width);
					int x2 = ran.nextInt(width);

					int y1 = ran.nextInt(height);
					int y2 = ran.nextInt(height);
					g.drawLine(x1,y1,x2,y2);
				}


				//3.将图片输出到页面展示
				ImageIO.write(image,"jpg",response.getOutputStream());


			}

			protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				this.doPost(request,response);
			}
		}

jsp：JavaServer Pages
	一、指令：用于配置JSP页面，导入资源文件
	格式：<%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %>
	三种指令：page、include、taglib
		1、page：
			例如：<%@ page contentType="text/html;charset=UTF-8" language="java" %>
			contentType：等同于response.setContentType()
				* 设置响应体的mime类型以及字符集
				* 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）
			import：导包
				<%@ page import="java.util.ArrayList" %>
			errorPage：当前页面发生异常后，会自动跳转到指定的错误页面
			isErrorPage：标识当前页是是否是错误页面。
				true：是，可以使用内置对象exception
				false：否。默认值。不可以使用内置对象exception
		2、include	： 页面包含的。导入页面的资源文件
			<%@include file="top.jsp"%>
		3、taglib： 导入资源
			<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
				prefix：前缀，自定义的
	二、注释
		1. html注释：
			<!-- -->:只能注释html代码片段
		2. jsp注释：推荐使用
			<%-- --%>：可以注释所有
	三、内置对象（9个）：在jsp页面中不需要创建，直接使用的对象
	其中前四个为域对象，可以在相应的域中共享数据
		变量名					真实类型						作用
		pageContext				PageContext					当前页面共享数据，还可以获取其他八个内置对象
		request					HttpServletRequest			一次请求访问的多个资源(转发)
		session					HttpSession					一次会话的多个请求间
		application				ServletContext				所有用户间共享数据
		response				HttpServletResponse			响应对象
		page					Object						当前页面(Servlet)的对象  this
		out						JspWriter					输出对象，数据输出到页面上
		config					ServletConfig				Servlet的配置对象
		exception				Throwable					异常对象

el表达式：Expression Language 表达式语言
	作用：替换和简化jsp页面中java代码的编写
	语法：${表达式}
	jsp默认支持el表达式的。如果要忽略el表达式：
		* 设置jsp中page指令中：isELIgnored="true" 忽略当前jsp页面中所有的el表达式
		* \${表达式} ：忽略当前这个el表达式
	一、运算
		1. 算数运算符： + - * /(div) %(mod)
			例如： ${3 + 4}  ${3 mod 4}
		2. 比较运算符： > < >= <= == !=
			例如： ${3 == 4}
		3. 逻辑运算符： &&(and) 、 ||(or) 、 !(not)
			例如： ${3 > 4  && 3 < 4}
		4. 空运算符：empty，用于判断字符串、集合、数组对象是否为null或者长度是否为0
			${empty list}:判断字符串、集合、数组对象是否为null或者长度为0
			${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0、
	二、获取值， el表达式只能从域对象中获取值
		1. ${域名称.键名}：从指定域中获取指定键的值
		例如：${requestScope.name} 获取request域中存储的 name=张三
			域名称（4个）：
				pageScope		--> pageContext
				requestScope 	--> request
				sessionScope 	--> session
				applicationScope --> application（ServletContext）
		2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。
			${name}
		3. 获取对象、List集合、Map集合的值
			* 对象：${域名称.键名.属性名}，本质上会去调用对象的getter方法
			例如：
				<%
					User user = new User();
					user.setName("张三");
					user.setAge(23);
					user.setBirthday(new Date());
					request.setAttribute("u",user);
					
					List list = new ArrayList();
					list.add("aaa");
					list.add("bbb");
					list.add(user);
					request.setAttribute("list",list);
					
					Map map = new HashMap();
					map.put("sname","李四");
					map.put("gender","男");
					map.put("user",user);
					request.setAttribute("map",map);
				%>
				${requestScope.u}<br>
				${requestScope.u.name}<br>
				${u.age}<br>
				${u.birthday}<br>
				${u.birthday.month}<br>
			* List集合：${域名称.键名[索引]}
				例如：${list[0]}  ${list[2].name}
			* Map集合（两种）:
				${域名称.键名.key名称}
				${域名称.键名["key名称"]}
				例如：${map.gender}  ${map["gender"]}   ${map.user.name}
				
	三、隐式对象
		el表达式中有11个隐式对象
			隐式对象			作用
			pageContext			对应于JSP页面中的pageContext对象
			pageScope			代表page域中用于保存属性的Map对象
			requestScope		代表request域中用于保存属性的Map对象
			sessionScope		代表session域中用于保存属性的Map对象
			applicationScope	代表application域中用于保存属性的Map对象
			param				表示一个保存了所有请求参数的Map对象
			paramValues			表示一个保存了所有请求参数的Map对象，它对于某个请求参数， 返回的是一个string类型数组
			header				表示一个保存了所有http请求头字段的Map对象
			headerValues		表示一个保存了所有http请求头字段的Map对象，返回string类型数组
			cookie				表示一个保存了所有cookie的Map对象
			initParam			表示一个保存了所有web应用初始化参数的map对象
		其中，pageContext 可以获取jsp其他八个内置对象
			${pageContext.request.contextPath}：动态获取虚拟目录

jstl：JavaServer Pages Tag Library  JSP标准标签库
	作用：用于简化和替换jsp页面上的java代码
	使用步骤：导入jstl相关jar包，引入标签库：taglib指令：<%@ taglib %>
	<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
	常用的JSTL标签：
	1、 c:if标签，相当于java代码的if语句
		<c:if test=""></c:if>
		test是必须属性，接受boolean表达式
			如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容
			一般情况下，test属性值会结合el表达式一起使用
			 c:if标签没有else情况，想要else情况，则可以再定义一个c:if标签
		例如：
		<%request.setAttribute("number",4);%>
		<c:if test="${number % 2 != 0}">
			${number}为奇数
		</c:if>
	2、 c:choose标签，相当于java代码的switch语句
		<c:choose></c:choose>
		使用choose标签声明  	相当于switch声明
		使用when标签做判断  	相当于case
		使用otherwise标签		相当于default
		例如：
		<%request.setAttribute("number",51);%>
		<c:choose>
			<c:when test="${number == 1}">星期一</c:when>
			<c:when test="${number == 2}">星期二</c:when>
			<c:when test="${number == 3}">星期三</c:when>
			<c:when test="${number == 4}">星期四</c:when>
			<c:when test="${number == 5}">星期五</c:when>
			<c:when test="${number == 6}">星期六</c:when>
			<c:when test="${number == 7}">星期天</c:when>
			<c:otherwise>数字输入有误</c:otherwise>
		</c:choose>
	3、 c:forEach标签，相当于java代码的for语句
		<c:forEach></c:forEach>
		两种for：
		第一种：for(int i = 0; i < 10; i ++)
			属性：
				begin：开始值
				end：结束值
				var：临时变量
				step：步长
				varStatus:循环状态对象
					index:容器中元素的索引，从0开始
					count:循环次数，从1开始
			例如：
				<c:forEach begin="1" end="10" var="i" step="2" varStatus="s">
					${i} <h3>${s.index}<h3> <h4> ${s.count} </h4><br>
				</c:forEach>
		第二种：for(User user : list)
			属性：
				items:容器对象
				var:容器中元素的临时变量
				varStatus:循环状态对象
					index:容器中元素的索引，从0开始
					count:循环次数，从1开始
			例如：
				<%
					List list = new ArrayList();
					list.add("aaa");
					list.add("bbb");
					list.add("ccc");
					request.setAttribute("list",list);
				%>

				<c:forEach items="${list}" var="str" varStatus="s">
					${s.index} ${s.count} ${str}<br>
				</c:forEach>

Filter：过滤器
	web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。
	过滤器的作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤等。
	步骤：
	· 定义一个类，实现接口Filter
	· 复写方法
	· 配置拦截路径（两种方式）
		* web.xml
		* 注解
	例如：
	@WebFilter("/*")//访问所有资源之前，都会执行该过滤器
	public class FilterDemo1 implements Filter {
	   @Override
		public void init(FilterConfig filterConfig) throws ServletException {		
					}		
		@Override
		public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
			System.out.println("filterDemo1被执行了....");	
			//放行		                filterChain.doFilter(servletRequest,servletResponse);
		 }		
			@Override
		public void destroy() {	
		 }
	}

	过滤器细节：
	1. web.xml配置 
	<filter>
		<filter-name>demo1</filter-name>
		<filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>demo1</filter-name>
		<!-- 拦截路径 -->
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	2. 过滤器执行流程
		· 执行过滤器
		· 执行放行后的资源
		· 回来执行过滤器放行代码下边的代码
	3. 过滤器生命周期方法
				* init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源
				* doFilter:每一次请求被拦截资源时，会执行。执行多次
				* destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源
	4. 过滤器配置详解
		* 拦截路径配置：
			· 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行
			· 拦截目录： /user/*	访问/user下的所有资源时，过滤器都会被执行
			· 后缀名拦截： *.jsp		访问所有后缀名为jsp资源时，过滤器都会被执行
			· 拦截所有资源：/*		访问所有资源时，过滤器都会被执行
		* 拦截方式配置：资源被访问的方式
			· 注解配置：设置dispatcherTypes属性
				1. REQUEST：默认值。浏览器直接请求资源
				2. FORWARD：转发访问资源
				3. INCLUDE：包含访问资源
				4. ERROR：错误跳转资源
				5. ASYNC：异步访问资源
			   · web.xml配置：设置<dispatcher></dispatcher>标签即可		
	5. 过滤器链(配置多个过滤器)
		* 执行顺序：如果有两个过滤器：过滤器1和过滤器2
			过滤器1
			过滤器2
			资源执行
			过滤器2
			过滤器1 

		* 过滤器先后顺序问题：
			1. 注解配置：按照类名的字符串比较规则比较，值小的先执行
				* 如： AFilter 和 BFilter，AFilter就先执行了。
			2. web.xml配置： <filter-mapping>谁定义在上边，谁先执行

Listener：监听器，web的三大组件之一。
	事件监听机制
		* 事件	：一件事情
		   * 事件源 ：事件发生的地方
		   * 监听器 ：一个对象
		* 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码。

	ServletContextListener
	监听ServletContext对象的创建和销毁方法：
	void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法
	void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法

	步骤：
		1. 定义一个类，实现ServletContextListener接口
		2. 复写方法
		3. 配置
			* web.xml
	<listener>
			 <listener-class>监听器的全类名</listener-class>
	</listener>
			指定初始化参数<context-param>
			* 注解：@WebListener


redis
	redis是一款高性能的NOSQL系列的非关系型数据库，NoSQL(NoSQL = Not Only SQL)，泛指非关系型的数据库。
	关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据。
	主流的NOSQL产品
	·键值(Key-Value)存储数据库
		相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB
		典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 
		数据模型： 一系列键值对
		优势： 快速查询
		劣势： 存储的数据缺少结构化
	·列存储数据库
		相关产品：Cassandra, HBase, Riak
		典型应用：分布式的文件系统
		数据模型：以列簇式存储，将同一列数据存在一起
		优势：查找速度快，可扩展性强，更容易进行分布式扩展
		劣势：功能相对局限
	·文档型数据库
		相关产品：CouchDB、MongoDB
		典型应用：Web应用（与Key-Value类似，Value是结构化的）
		数据模型： 一系列键值对
		优势：数据结构要求不严格
		劣势： 查询性能不高，而且缺乏统一的查询语法
	·图形(Graph)数据库
		相关数据库：Neo4J、InfoGrid、Infinite Graph
		典型应用：社交网络
		数据模型：图结构
		优势：利用图结构相关算法。
		劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。

	Redis
	Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，目前为止Redis支持的键值数据类型如下：
		1) 字符串类型 string
		2) 哈希类型 hash
		3) 列表类型 list
		4) 集合类型 set
		5) 有序集合类型 sortedset
	redis的应用场景
		• 缓存（数据查询、短连接、新闻内容、商品内容等等）
		• 聊天室的在线好友列表
		• 任务队列。（秒杀、抢购、12306等等）
		• 应用排行榜
		• 网站访问统计
		• 数据过期处理（可以精确到毫秒
		• 分布式集群架构中的session分离
	解压后直接可以使用：
		* redis.windows.conf：配置文件
		* redis-cli.exe：redis的客户端
		* redis-server.exe：redis服务器端
	redis的数据结构：
	* redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构
	* value的数据结构：
		1) 字符串类型 string
		2) 哈希类型 hash ： map格式  
		3) 列表类型 list ： linkedlist格式。支持重复元素
		4) 集合类型 set  ： 不允许重复元素
		5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序

	命令行操作五种不同数据结构：		
	字符串类型 string
	1. 存储： set key value
		127.0.0.1:6379> set username zhangsan
		OK
	2. 获取： get key
		127.0.0.1:6379> get username
		"zhangsan"
	3. 删除： del key
		127.0.0.1:6379> del age
		(integer) 1
	哈希类型 hash
	1. 存储： hset key field value
		127.0.0.1:6379> hset myhash username lisi
		(integer) 1
		127.0.0.1:6379> hset myhash password 123
		(integer) 1
	2. 获取： 
		* hget key field: 获取指定的field对应的值
		127.0.0.1:6379> hget myhash username
		"lisi"
		* hgetall key：获取所有的field和value
		127.0.0.1:6379> hgetall myhash
		1) "username"
		2) "lisi"
		3) "password"
		4) "123"
	3. 删除： hdel key field
		127.0.0.1:6379> hdel myhash username
		(integer) 1
	列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）
	1. 添加：
		* lpush key value: 将元素加入列表左表边				
		* rpush key value：将元素加入列表右边
		127.0.0.1:6379> lpush myList a
		(integer) 1
		127.0.0.1:6379> lpush myList b
		(integer) 2
		127.0.0.1:6379> rpush myList c
		(integer) 3
	2. 获取：
		lrange key start end ：范围获取
		127.0.0.1:6379> lrange myList 0 -1
		1) "b"
		2) "a"
		3) "c"
	3. 删除：
		* lpop key： 删除列表最左边的元素，并将元素返回
		* rpop key： 删除列表最右边的元素，并将元素返回
	集合类型 set ： 不允许重复元素
	1. 存储：sadd key value
		127.0.0.1:6379> sadd myset a
		(integer) 1
		127.0.0.1:6379> sadd myset a
		(integer) 0
	2. 获取：smembers key:获取set集合中所有元素
		127.0.0.1:6379> smembers myset
		1) "a"
	3. 删除：srem key value:删除set集合中的某个元素	
		127.0.0.1:6379> srem myset a
		(integer) 1
	有序集合类型 sortedset：
	不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
	1. 存储：zadd key score value
		127.0.0.1:6379> zadd mysort 60 zhangsan
		(integer) 1
		127.0.0.1:6379> zadd mysort 50 lisi
		(integer) 1
		127.0.0.1:6379> zadd mysort 80 wangwu
		(integer) 1
	2. 获取：zrange key start end [withscores]
		127.0.0.1:6379> zrange mysort 0 -1
		1) "lisi"
		2) "zhangsan"
		3) "wangwu"

		127.0.0.1:6379> zrange mysort 0 -1 withscores
		1) "zhangsan"
		2) "60"
		3) "wangwu"
		4) "80"
		5) "lisi"
		6) "500"
	3. 删除：zrem key value
		127.0.0.1:6379> zrem mysort lisi
		(integer) 1

	通用命令
		1. keys * : 查询所有的键
		2. type key ： 获取键对应的value的类型
		3. del key：删除指定的key value


	持久化
	redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。
	redis持久化机制：
	1. RDB：默认方式，不需要进行配置，默认就使用这种机制
		在一定的间隔时间中，检测key的变化情况，然后持久化数据
		编辑redis.windwos.conf文件
			#   after 900 sec (15 min) if at least 1 key changed
			save 900 1
			#   after 300 sec (5 min) if at least 10 keys changed
			save 300 10
			#   after 60 sec if at least 10000 keys changed
			save 60 10000
		重新启动redis服务器，并指定配置文件名称
	2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据
		编辑redis.windwos.conf文件
			appendonly no（关闭aof） --> appendonly yes （开启aof）
			# appendfsync always ： 每一次操作都进行持久化
			appendfsync everysec ： 每隔一秒进行一次持久化
			# appendfsync no	 ： 不进行持久化

	Java客户端 Jedis
	Jedis: 一款java操作redis数据库的工具.
	使用步骤：
		1. 下载jedis的jar包
		2. 使用
		//1. 获取连接
		   Jedis jedis = new Jedis("localhost",6379);
		   //2. 操作
		   jedis.set("username","zhangsan");
			//3. 关闭连接
			jedis.close();
	Jedis操作各种redis中的数据结构
	1) 字符串类型 string
			set
			get			
		 //1. 获取连接
		Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		//2. 操作
		//存储
		jedis.set("username","zhangsan");
		//获取
		String username = jedis.get("username");
		System.out.println(username);
		//可以使用setex()方法存储可以指定过期时间的 key value
		jedis.setex("activecode",20,"hehe");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对
		//3. 关闭连接
		jedis.close();

	2) 哈希类型 hash ： map格式  
		hset
			hget
			hgetAll
		//1. 获取连接
		Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		 //2. 操作
		// 存储hash
		jedis.hset("user","name","lisi");
		jedis.hset("user","age","23");
		jedis.hset("user","gender","female");
		 // 获取hash
		String name = jedis.hget("user", "name");
		System.out.println(name);
		// 获取hash的所有map中的数据
		Map<String, String> user = jedis.hgetAll("user");
		// keyset
		  Set<String> keySet = user.keySet();
		for (String key : keySet) {
			//获取value
			String value = user.get(key);
			System.out.println(key + ":" + value);
		   }
		//3. 关闭连接
		jedis.close();


	3) 列表类型 list ： linkedlist格式。支持重复元素
		lpush / rpush
		lpop / rpop
		lrange start end : 范围获取
		//1. 获取连接
		Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		   //2. 操作
		// list 存储
		jedis.lpush("mylist","a","b","c");//从左边存
		jedis.rpush("mylist","a","b","c");//从右边存
		// list 范围获取
		  List<String> mylist = jedis.lrange("mylist", 0, -1);
		System.out.println(mylist);
		// list 弹出
		String element1 = jedis.lpop("mylist");//c
		System.out.println(element1);
		String element2 = jedis.rpop("mylist");//c
		System.out.println(element2);
		// list 范围获取
		List<String> mylist2 = jedis.lrange("mylist", 0, -1);
		System.out.println(mylist2);	
		 //3. 关闭连接
		jedis.close();

	4) 集合类型 set  ： 不允许重复元素
		sadd
		smembers:获取所有元素

		//1. 获取连接
		   Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		 //2. 操作
		// set 存储
		jedis.sadd("myset","java","php","c++");
		// set 获取
		Set<String> myset = jedis.smembers("myset");
		   System.out.println(myset);
		//3. 关闭连接
		jedis.close();
	5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序
		zadd
		zrange

		//1. 获取连接
		Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
		//2. 操作
		// sortedset 存储
		jedis.zadd("mysortedset",3,"亚瑟");
		   jedis.zadd("mysortedset",30,"后裔");
		jedis.zadd("mysortedset",55,"孙悟空");
		// sortedset 获取
		Set<String> mysortedset = jedis.zrange("mysortedset", 0, -1);
		System.out.println(mysortedset);
		//3. 关闭连接
		   jedis.close();

	jedis连接池： JedisPool
		使用：
		1. 创建JedisPool连接池对象
		2. 调用方法 getResource()方法获取Jedis连接
		//0.创建一个配置对象
		JedisPoolConfig config = new JedisPoolConfig();
		config.setMaxTotal(50);
		config.setMaxIdle(10);
		//1.创建Jedis连接池对象
		JedisPool jedisPool = new JedisPool(config,"localhost",6379);
		//2.获取连接
		  Jedis jedis = jedisPool.getResource();
		//3. 使用
		jedis.set("hehe","heihei");
		//4. 关闭 归还到连接池中
		jedis.close();
	连接池工具类
	public class JedisPoolUtils {

		private static JedisPool jedisPool;
		static{
			//读取配置文件
			InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");
			 //创建Properties对象
			Properties pro = new Properties();
			//关联文件
			try {
				pro.load(is);
			 } catch (IOException e) {
				e.printStackTrace();
			}
			//获取数据，设置到JedisPoolConfig中
			JedisPoolConfig config = new JedisPoolConfig();
					config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal")));
					config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle")));
				  //初始化JedisPool
				jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port")));
		}
		/**
		* 获取连接方法
		*/
		public static Jedis getJedis(){
			return jedisPool.getResource();
		}
	}


代理模式：代理对象代理真实对象，达到增强真实对象功能的目的
	动态代理：在内存中形成代理类
		* 实现步骤：
		1. 代理对象和真实对象实现相同的接口
		2. 代理对象 = Proxy.newProxyInstance();
		3. 使用代理对象调用方法。
	4. 增强方法
		* 增强方式：
		1. 增强参数列表
		2. 增强返回值类型
		3. 增强方法体执行逻辑
	一个例子介绍一下代理模式，这里有一个卖电脑的接口 SaleComputer和该接口的实现类联想电脑 Lenovo，我们使用代理模式来增强实现类Lenove的功能

	SaleComputer接口

	package cn.figo.web.proxy;

	public interface SaleComputer {

		public String sale(double money);

		public void show();
	}

	Lenove实现类

	package cn.figo.web.proxy;

	/**
	 * 真实类
	 */
	public class Lenovo implements SaleComputer {
		@Override
		public String sale(double money) {

			System.out.println("花了"+money+"元买了一台联想电脑...");
			return "联想电脑";
		}

		@Override
		public void show() {
			System.out.println("展示电脑....");
		}
	}

	代理模式对Lenove中的sale功能的增强

	package cn.figo.web.proxy;

	import java.lang.reflect.InvocationHandler;
	import java.lang.reflect.Method;
	import java.lang.reflect.Proxy;

	public class ProxyTest {

		public static void main(String[] args) {
			//1.创建真实对象
			Lenovo lenovo = new Lenovo();
			
			//2.动态代理增强lenovo对象
			/*
				三个参数：
					1. 类加载器：真实对象.getClass().getClassLoader()
					2. 接口数组：真实对象.getClass().getInterfaces()
					3. 处理器：new InvocationHandler()
			 */
			SaleComputer proxy_lenovo = (SaleComputer) Proxy.newProxyInstance(lenovo.getClass().getClassLoader(), lenovo.getClass().getInterfaces(), new InvocationHandler() {

				/*
					代理逻辑编写的方法：代理对象调用的所有方法都会触发该方法执行
						参数：
							1. proxy:代理对象
							2. method：代理对象调用的方法，被封装为的对象
							3. args:代理对象调用的方法时，传递的实际参数
				 */
				@Override
				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
					/*System.out.println("该方法执行了....");
					System.out.println(method.getName());
					System.out.println(args[0]);
				  */
					//判断是否是sale方法
					if(method.getName().equals("sale")){
						//1.增强参数
						double money = (double) args[0];
						money = money * 0.85;
						System.out.println("专车接你....");
						//使用真实对象调用该方法
						String obj = (String) method.invoke(lenovo, money);
						System.out.println("免费送货...");
						//2.增强返回值
						return obj+"_鼠标垫";
					}else{
						Object obj = method.invoke(lenovo, args);
						return obj;
					}
				}
			});

			//3.调用方法

		   /* String computer = proxy_lenovo.sale(8000);
			System.out.println(computer);*/

			proxy_lenovo.show();
		}
	}
	

maven
	Maven 是一个项目管理工具，它包含了一个项目对象模型 (POM： Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，
	一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。
maven可以干什么：
	能帮你构建工程，管理 jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站点
maven对jar包的管理
	maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar包的坐标，这样就很好的避免了 jar 直接引入进来，
	在需要用到 jar 包的时候，只要查找 pom.xml 文件，再通过 pom.xml 文件中的坐标，到一个专门用于”存放 jar 包的仓库”(maven 仓库)中根据坐标从而找到这些 jar 包，再把这些 jar 包拿去运行。
maven一键构建
	我们的项目，往往都要经历编译、 测试、 运行、 打包、 安装 ，部署等一系列过程。
	什么是构建？指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理，这个过程称为构建。
	一键构建指的是整个构建过程，使用 maven 一个命令可以轻松完成整个工作
	通过 mvn tomcat:run 的这个命令，我们发现现在的工程编译，测试，运行都变得非常简单
maven仓库
	本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找。
		默认本地仓库位置在 ${user.dir}/.m2/repository， ${user.dir}表示 windows 用户目录。
	远程仓库：如果本地需要插件或者 jar 包，本地仓库没有， 默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。
	中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，
		它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。
maven标准目录结构
	├─.settings
	└─src
		├─main
		│  ├─java
		│  │  └─cn
		│  │      └─itcast
		│  │          └─maven
		│  │              └─servlet
		│  ├─resources
		│  └─webapp
		│      ├─jsp
		│      └─WEB-INF
		└─test
			├─java
			│  └─cn
			│      └─itcast
			│          └─maven
			│              └─test
			└─resources
	src/main/java —— 存放项目的.java 文件
	src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件
	src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类
	src/test/resources —— 测试资源文件
	target —— 项目输出位置，编译后的 class 文件会输出到此目录
	pom.xml——maven 项目核心配置文件
	注意：如果是普通的 java 项目，那么就没有 webapp 目录
			
maven常用命令 
	clean、 compile 、test、 package、 install、tomcat:run
	compile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target目录下。
	mvn compile
	test 是 maven 工程的测试命令 mvn test，会执行 src/test/java 下的单元测试类。
	clean 是 maven 工程的清理命令，执行 clean 会删除 target 目录及内容
	package 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war包。
	install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。
	tomcat:run 可以运行Maven 工程。进入 maven 工程目录（当前目录有 pom.xml 文件），运行 tomcat:run 命令。
maven的pom.xml文件内容
	<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		<modelVersion>4.0.0</modelVersion>
		<groupId>cn.itcast.maven</groupId>
		<artifactId>maven-helloworld</artifactId>
		<version>0.0.1-SNAPSHOT</version>
		<packaging>war</packaging>
		<name>第一个maven工程</name>
		<description>第一个maven工程</description>
		
		<!-- 添加servlet-api，jsp-api -->
		<dependencies>
			<dependency>
				<groupId>junit</groupId>
				<artifactId>junit</artifactId>
				<version>4.9</version>
				<scope>test</scope>
			</dependency>


			<dependency>
				<groupId>javax.servlet.jsp</groupId>
				<artifactId>jsp-api</artifactId>
				<version>2.0</version>
				<scope>provided</scope>
			</dependency>
			<dependency>
				<groupId>javax.servlet</groupId>
				<artifactId>servlet-api</artifactId>
				<version>2.5</version>
				<scope>provided</scope>
			</dependency>
		</dependencies>
		<build>
			<!-- 配置了很多插件 -->
			<plugins>
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-compiler-plugin</artifactId>
					<configuration>
						<source>1.7</source>
						<target>1.7</target>
						<encoding>UTF-8</encoding>
					</configuration>
				</plugin>
			<plugin>
					<groupId>org.apache.tomcat.maven</groupId>
					<artifactId>tomcat7-maven-plugin</artifactId>
					<version>2.1</version>
					<configuration>
						<port>9090</port>
						<path>/mgr</path>
						<uriEncoding>UTF-8</uriEncoding>
						<server>tomcat7</server>
					</configuration>
				</plugin>

			</plugins>
		</build>
	</project>

命令演示	
D:\1_Code\java\maven-helloworld>mvn clean
[INFO] Scanning for projects...
[WARNING]
[WARNING] Some problems were encountered while building the effective model for cn.itcast.maven:maven-helloworld:war:0.0.1-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 37, column 12
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building 第一个maven工程 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ maven-helloworld ---
[INFO] Deleting D:\1_Code\java\maven-helloworld\target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.926 s
[INFO] Finished at: 2019-10-16T01:07:13+08:00
[INFO] Final Memory: 6M/24M
[INFO] ------------------------------------------------------------------------

D:\1_Code\java\maven-helloworld>mvn compile
[INFO] Scanning for projects...
[WARNING]
[WARNING] Some problems were encountered while building the effective model for cn.itcast.maven:maven-helloworld:war:0.0.1-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 37, column 12
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building 第一个maven工程 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ maven-helloworld ---
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ maven-helloworld ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to D:\1_Code\java\maven-helloworld\target\classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.496 s
[INFO] Finished at: 2019-10-16T01:07:29+08:00
[INFO] Final Memory: 11M/40M
[INFO] ------------------------------------------------------------------------

D:\1_Code\java\maven-helloworld>mvn clean
[INFO] Scanning for projects...
[WARNING]
[WARNING] Some problems were encountered while building the effective model for cn.itcast.maven:maven-helloworld:war:0.0.1-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 37, column 12
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building 第一个maven工程 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ maven-helloworld ---
[INFO] Deleting D:\1_Code\java\maven-helloworld\target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.427 s
[INFO] Finished at: 2019-10-16T01:08:15+08:00
[INFO] Final Memory: 6M/24M
[INFO] ------------------------------------------------------------------------

D:\1_Code\java\maven-helloworld>mvn test
[INFO] Scanning for projects...
[WARNING]
[WARNING] Some problems were encountered while building the effective model for cn.itcast.maven:maven-helloworld:war:0.0.1-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 37, column 12
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building 第一个maven工程 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ maven-helloworld ---
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ maven-helloworld ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to D:\1_Code\java\maven-helloworld\target\classes
[INFO]
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ maven-helloworld ---
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven-helloworld ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to D:\1_Code\java\maven-helloworld\target\test-classes
[INFO]
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ maven-helloworld ---
[INFO] Surefire report directory: D:\1_Code\java\maven-helloworld\target\surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running cn.itcast.maven.test.HelloTest
hello test....
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.065 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 4.883 s
[INFO] Finished at: 2019-10-16T01:08:29+08:00
[INFO] Final Memory: 12M/44M
[INFO] ------------------------------------------------------------------------
D:\1_Code\java\maven-helloworld>mvn clean
[INFO] Scanning for projects...
[WARNING]
[WARNING] Some problems were encountered while building the effective model for cn.itcast.maven:maven-helloworld:war:0.0.1-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 37, column 12
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building 第一个maven工程 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ maven-helloworld ---
[INFO] Deleting D:\1_Code\java\maven-helloworld\target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.473 s
[INFO] Finished at: 2019-10-16T01:09:15+08:00
[INFO] Final Memory: 6M/24M
[INFO] ------------------------------------------------------------------------

D:\1_Code\java\maven-helloworld>mvn package
[INFO] Scanning for projects...
[WARNING]
[WARNING] Some problems were encountered while building the effective model for cn.itcast.maven:maven-helloworld:war:0.0.1-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 37, column 12
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building 第一个maven工程 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ maven-helloworld ---
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ maven-helloworld ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to D:\1_Code\java\maven-helloworld\target\classes
[INFO]
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ maven-helloworld ---
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven-helloworld ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to D:\1_Code\java\maven-helloworld\target\test-classes
[INFO]
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ maven-helloworld ---
[INFO] Surefire report directory: D:\1_Code\java\maven-helloworld\target\surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running cn.itcast.maven.test.HelloTest
hello test....
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.071 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- maven-war-plugin:2.2:war (default-war) @ maven-helloworld ---
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.thoughtworks.xstream.core.util.Fields (file:/D:/develop/maven_repository/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar) to field java.util.Properties.defaults
WARNING: Please consider reporting this to the maintainers of com.thoughtworks.xstream.core.util.Fields
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
[INFO] Packaging webapp
[INFO] Assembling webapp [maven-helloworld] in [D:\1_Code\java\maven-helloworld\target\maven-helloworld-0.0.1-SNAPSHOT]
[INFO] Processing war project
[INFO] Copying webapp resources [D:\1_Code\java\maven-helloworld\src\main\webapp]
[INFO] Webapp assembled in [67 msecs]
[INFO] Building war: D:\1_Code\java\maven-helloworld\target\maven-helloworld-0.0.1-SNAPSHOT.war
[INFO] WEB-INF\web.xml already added, skipping
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.411 s
[INFO] Finished at: 2019-10-16T01:09:35+08:00
[INFO] Final Memory: 13M/47M
[INFO] ------------------------------------------------------------------------

D:\1_Code\java\maven-helloworld>mvn clean
[INFO] Scanning for projects...
[WARNING]
[WARNING] Some problems were encountered while building the effective model for cn.itcast.maven:maven-helloworld:war:0.0.1-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 37, column 12
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building 第一个maven工程 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ maven-helloworld ---
[INFO] Deleting D:\1_Code\java\maven-helloworld\target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.525 s
[INFO] Finished at: 2019-10-16T01:11:28+08:00
[INFO] Final Memory: 6M/27M
[INFO] ------------------------------------------------------------------------

D:\1_Code\java\maven-helloworld>mvn install
[INFO] Scanning for projects...
[WARNING]
[WARNING] Some problems were encountered while building the effective model for cn.itcast.maven:maven-helloworld:war:0.0.1-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-compiler-plugin is missing. @ line 37, column 12
[WARNING]
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING]
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING]
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building 第一个maven工程 0.0.1-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ maven-helloworld ---
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ maven-helloworld ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to D:\1_Code\java\maven-helloworld\target\classes
[INFO]
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ maven-helloworld ---
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 0 resource
[INFO]
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven-helloworld ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to D:\1_Code\java\maven-helloworld\target\test-classes
[INFO]
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ maven-helloworld ---
[INFO] Surefire report directory: D:\1_Code\java\maven-helloworld\target\surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running cn.itcast.maven.test.HelloTest
hello test....
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.059 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- maven-war-plugin:2.2:war (default-war) @ maven-helloworld ---
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.thoughtworks.xstream.core.util.Fields (file:/D:/develop/maven_repository/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar) to field java.util.Properties.defaults
WARNING: Please consider reporting this to the maintainers of com.thoughtworks.xstream.core.util.Fields
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
[INFO] Packaging webapp
[INFO] Assembling webapp [maven-helloworld] in [D:\1_Code\java\maven-helloworld\target\maven-helloworld-0.0.1-SNAPSHOT]
[INFO] Processing war project
[INFO] Copying webapp resources [D:\1_Code\java\maven-helloworld\src\main\webapp]
[INFO] Webapp assembled in [71 msecs]
[INFO] Building war: D:\1_Code\java\maven-helloworld\target\maven-helloworld-0.0.1-SNAPSHOT.war
[INFO] WEB-INF\web.xml already added, skipping
[INFO]
[INFO] --- maven-install-plugin:2.4:install (default-install) @ maven-helloworld ---
[INFO] Installing D:\1_Code\java\maven-helloworld\target\maven-helloworld-0.0.1-SNAPSHOT.war to D:\develop\maven_repository\cn\itcast\maven\maven-helloworld\0.0.1-SNAPSHOT\maven-helloworld-0.0.1-SNAPSHOT.war
[INFO] Installing D:\1_Code\java\maven-helloworld\pom.xml to D:\develop\maven_repository\cn\itcast\maven\maven-helloworld\0.0.1-SNAPSHOT\maven-helloworld-0.0.1-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.540 s
[INFO] Finished at: 2019-10-16T01:11:41+08:00
[INFO] Final Memory: 13M/48M
[INFO] ------------------------------------------------------------------------


踩坑记录：
从中央仓库下载指定的包
mvn dependency:get -DremoteRepositories=url -DgroupId=groupId -DartifactId=artifactId -Dversion=version


注解中不加/引发的错误 @WebServlet("regeistUserServlet")
Failed to execute goal org.apache.tomcat.maven:tomcat7-maven-plugin:2.1:run (default-cli)

不加 ?useUnicode=true&characterEncoding=utf-8 汉字写入mysql会显示 ?
url=jdbc:mysql:///travel?useUnicode=true&characterEncoding=utf-8

运行前先打开redis的server


技术选型
Web层
	a)	Servlet：前端控制器
	b)	html：视图
	c)	Filter：过滤器
	d)	BeanUtils：数据封装
	e)	Jackson：json序列化工具
Service层
	f)	Javamail：java发送邮件工具
	g)	Redis：nosql内存数据库
	h)	Jedis：java的redis客户端
Dao层
	i)	Mysql：数据库
	j)	Druid：数据库连接池
	k)	JdbcTemplate：jdbc的工具


注册 登录 退出


