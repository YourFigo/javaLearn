mybatis
简介
	1、 mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，
	而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。
	2、 mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中sql 的动态参数
	进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。
	3、 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，
	使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。

基于xml的快速实现
创建一个maven工程，并在工程中创建如下目录
	mybatis_1
		└─src
			├─main
			│  ├─java
			│  │  └─cn
			│  │      └─figo
			│  │          ├─dao
			│  │          └─domain
			│  └─resources
			│      └─cn
			│          └─figo
			│              └─dao
			└─test
				└─java
					└─cn
						└─figo
							└─test
在pom.xml中导入依赖
	<?xml version="1.0" encoding="UTF-8"?>
	<project xmlns="http://maven.apache.org/POM/4.0.0"
			 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		<modelVersion>4.0.0</modelVersion>

		<groupId>cn.figo</groupId>
		<artifactId>mybatis_learn</artifactId>
		<version>1.0-SNAPSHOT</version>

		<dependencies>
			<dependency>
				<groupId>org.mybatis</groupId>
				<artifactId>mybatis</artifactId>
				<version>3.4.5</version>
			</dependency>
			<dependency>
				<groupId>mysql</groupId>
				<artifactId>mysql-connector-java</artifactId>
				<version>5.1.6</version>
			</dependency>
			<dependency>
				<groupId>log4j</groupId>
				<artifactId>log4j</artifactId>
				<version>1.2.12</version>
			</dependency>
			<dependency>
				<groupId>junit</groupId>
				<artifactId>junit</artifactId>
				<version>4.10</version>
				<scope>test</scope>
			</dependency>
		</dependencies>
	</project>

创建cn.figo.domain.User.java和cn.figo.dao.IUserDao.java
	package cn.figo.domain;

	import java.io.Serializable;
	import java.util.Date;

	public class User implements Serializable{

		private Integer id;
		private String username;
		private Date birthday;
		private String sex;
		private String address;

		public Integer getId() {
			return id;
		}

		public void setId(Integer id) {
			this.id = id;
		}

		public String getUsername() {
			return username;
		}

		public void setUsername(String username) {
			this.username = username;
		}

		public Date getBirthday() {
			return birthday;
		}

		public void setBirthday(Date birthday) {
			this.birthday = birthday;
		}

		public String getSex() {
			return sex;
		}

		public void setSex(String sex) {
			this.sex = sex;
		}

		public String getAddress() {
			return address;
		}

		public void setAddress(String address) {
			this.address = address;
		}

		@Override
		public String toString() {
			return "User{" +
					"id=" + id +
					", username='" + username + '\'' +
					", birthday=" + birthday +
					", sex='" + sex + '\'' +
					", address='" + address + '\'' +
					'}';
		}
	}

	package cn.figo.dao;

	import cn.figo.domain.User;
	import java.util.List;

	/**
	 * 用户的持久层接口
	 */
	public interface IUserDao {

		/**
		 * 查询所有操作
		 * @return
		 */
		List<User> findAll();
	}

创建持久层接口dao的映射文件 src\main\resources\cn\figo\dao\IUserDao.xml
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE mapper
			PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
	<mapper namespace="cn.figo.dao.IUserDao">
		<!--配置查询所有-->
		<select id="findAll" resultType="cn.figo.domain.User">
			select * from user
		</select>
	</mapper>

创建mybatis的主配置文件 src\main\resources\SqlMapConfig.xml
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE configuration
			PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
			"http://mybatis.org/dtd/mybatis-3-config.dtd">
	<!-- mybatis的主配置文件 -->
	<configuration>
		<!-- 配置环境 -->
		<environments default="mysql">
			<!-- 配置mysql的环境-->
			<environment id="mysql">
				<!-- 配置事务的类型-->
				<transactionManager type="JDBC"></transactionManager>
				<!-- 配置数据源（连接池） -->
				<dataSource type="POOLED">
					<!-- 配置连接数据库的4个基本信息 -->
					<property name="driver" value="com.mysql.jdbc.Driver"/>
					<property name="url" value="jdbc:mysql://localhost:3306/ssm_mybatis"/>
					<property name="username" value="root"/>
					<property name="password" value="123456"/>
				</dataSource>
			</environment>
		</environments>

		<!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 -->
		<mappers>
			<mapper resource="cn/figo/dao/IUserDao.xml"/>
		</mappers>
	</configuration>

然后在测试包中写一个测试类查询一下数据 src\test\java\cn\figo\test\MybatisTest.java
	package cn.figo.test;

	import cn.figo.dao.IUserDao;
	import cn.figo.domain.User;
	import org.apache.ibatis.io.Resources;
	import org.apache.ibatis.session.SqlSession;
	import org.apache.ibatis.session.SqlSessionFactory;
	import org.apache.ibatis.session.SqlSessionFactoryBuilder;

	import java.io.InputStream;
	import java.util.List;

	/**
	 * mybatis的入门案例
	 * @Author Figo
	 * @Date 2019/10/27 14:22
	 */
	public class MybatisTest {

		/**
		 * 入门案例
		 * @param args
		 */
		public static void main(String[] args)throws Exception {
			//1.读取配置文件
			InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");
			//2.创建SqlSessionFactory工厂
			SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
			SqlSessionFactory factory = builder.build(in);
			//3.使用工厂生产SqlSession对象
			SqlSession session = factory.openSession();
			//4.使用SqlSession创建Dao接口的代理对象
			IUserDao userDao = session.getMapper(IUserDao.class);
			//5.使用代理对象执行方法
			List<User> users = userDao.findAll();
			for(User user : users){
				System.out.println(user);
			}
			//6.释放资源
			session.close();
			in.close();
		}
	}
	注意事项：
	持久层接口dao的映射文件创建的位置必须和持久层接口在相同的包中，都为cn.figo.dao，否则mybatis找不到对应的类。
	注意目录为：resources\cn\figo\dao\IUserDao.xml，而不是：resources\cn.figo.dao\IUserDao.xml，中间为三级目录。

基于注解配置mybatis
	注解配置mybatis不需要映射文件，在持久层的相应方法前加一个注解并在主配置文件中指定持久层接口位置即可
	package cn.figo.dao;

	import cn.figo.domain.User;
	import org.apache.ibatis.annotations.Select;

	import java.util.List;

	/**
	 * 用户的持久层接口
	 */
	public interface IUserDao {

		/**
		 * 查询所有操作
		 * @return
		 */
		@Select("select * from user")
		List<User> findAll();
	}
	
	修改主配置文件中的mapper
	<!-- 如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名 -->
    <mappers>
        <mapper class="cn.figo.dao.IUserDao"/>
    </mappers>

入门案例的main方法分析
	第一步：读取配置文件
	第二步：创建SqlSessionFactory工厂
	第三步：创建SqlSession
	第四步：创建Dao接口的代理对象
	第五步：执行dao中的方法
	第六步：释放资源
	注意事项：
		不要忘记在映射配置中告知mybatis要封装到哪个实体类中。配置的方式：指定实体类的全限定类名。
	这里涉及到了mybatis源码中的四个类和接口：
		class Resources
		class SqlSessionFactoryBuilder
		interface SqlSessionFactory
		interface SqlSession
	用到了三种设计模式：
		构建者模式
		工厂模式
		代理模式

XML配置的mybatis执行过程分析
	1、mybatis这里首先需要先读取主配置文件和映射配置文件中的内容，这些内容中包括：
		配置连接数据库的4个基本信息
			<property name="driver" value="com.mysql.jdbc.Driver"/>
			<property name="url" value="jdbc:mysql://localhost:3306/ssm_mybatis"/>
			<property name="username" value="root"/>
			<property name="password" value="123456"/>
		映射配置的位置
			<mappers>
				<mapper resource="cn/figo/dao/IUserDao.xml"/>
			</mappers>
		映射文件中的具体信息：持久层接口，需要执行sql语句的方法，所要执行的sql语句和sql查询后的结果要封装的数据类型
			<mapper namespace="cn.figo.dao.IUserDao">
				<!--配置查询所有-->
				<select id="findAll" resultType="cn.figo.domain.User">
					select * from user
				</select>
			</mapper>
		这里可以将读取后的数据封装进一个Mapper中，供后续读取。可以根据持久层接口的唯一方法来找到：
		要执行的sql语句和要封装的实体类的全限定类名。
		Mapper(cn.figo.dao.IUserDao.findAll-->
			Mapper(
				domainClassPath-->cn.figo.domain.User,
				sql-->"select * from user")
		)
		Mybatis是通过Resources类来读取xml的
	2、通过SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession，使用构建者模式，工厂模式和代理模式来产生持久层接口的代理实现类。
		产生的代理类可以执行以下3、4、5、6操作，最后返回查询结果的封装集合List<E>。
		其中代理对象是通过SqlSession的方法 <T> T getMapper(Class<T> type) 来实现的。
		可想而知，如果getMapper方法中使用的jdk中的动态代理的话，那其中最重要的的代码便是：
		Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
		这个方法有三个参数：
			ClassLoader用于加载被代理对象的字节码，这个类加载器和被代理对象使用相同的类加载器，因此是IUserDao.class.getClassLoader()
			interfaces 是被代理对象所有实现的接口的字节码数组，用于让代理对象和被代理对象有相同的方法，因此是IUserDao.class.getInterfaces()
			InvocationHandler是最主要的参数，用于提供代理功能，代理类的增强功能就是在第三个参数实现的，第三个参数需要实现InvocationHandler接口中的invoke()方法
		因此一般JDK动态代理的代码为：
		Proxy.newProxyInstance(IUserDao.class.getClassLoader(), IUserDao.class.getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                return null;
            }
        });
		被代理类中的所有方法，都会被InvocationHandler中的invoke方法拦截，最终使用的是代理类中增强后的该方法。
		invoke中的三个参数分别为：代理对象的引用proxy，当前拦截(执行)的方法method，该方法的参数列表args
	3、框架将得到的这些信息获取后就可以，进行注册驱动，获得数据库连接Connection对象
	4、根据sql语句和连接来获取预处理对象preparedStatement：conn.prepareStatement(sql)
	5、执行查询，获得结果集：ResultSet rs = preparedStatement.executeQuery();
	6、遍历结果集，然后根据配置文件中的Bean进行封装，最后返回一个包含封装后的结果集的 list<User>
		其中封装时，由于框架是在运行时获取的Bean的相关属性等信息，所以需要使用反射技术。通过反射技术，
		根据全限定类名拿到需要封装的对象 Class.forName(cn.figo.domain.User)，由于实体类中的属性和数据库
		表中的字段名是相同的，因此可以通过反射，拿到Bean的所有属性进行赋值封装，每封装好一个元素，就将该
		元素加到list中 list.add(element)。
	
自定义mybatis框架基于XML的实现
	我们移除pom.xml中的mybatis相关的坐标后，自定义一个mabatis框架，实现 "select * from user" 的功能。
	最终我们的目录结构如下：
	src
	├─main
	│  ├─java
	│  │  └─cn
	│  │      └─figo
	│  │          ├─dao
	│  │          ├─domain
	│  │          └─mybatis
	│  │              ├─annotation
	│  │              ├─cfg
	│  │              ├─io
	│  │              ├─sqlsession
	│  │              │  ├─defaults
	│  │              │  └─proxy
	│  │              └─utils
	│  └─resources
	│      └─cn
	│          └─figo
	│              └─dao
	└─test
		└─java
			└─cn
				└─figo
					└─test

基于xml的mybatis的crud操作
1、
	<!-- 根据 id 查询 -->
	<select id="findById" resultType="cn.figo.domain.User" parameterType="int">
		select * from user where id = #{uid}
	</select>
	resultType 属性：
		用于指定封装结果集的类型。
	parameterType 属性：
		用于指定传入参数的类型。
	sql 语句中使用#{}字符：
		它代表占位符， 相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。
		具体的数据是由#{}里面的内容决定的。
2、	
	<!-- 保存用户-->
	<insert id="saveUser" parameterType="cn.figo.domain.User">
		insert into user(username,birthday,sex,address) values (#{username},#{birthday},#{sex},#{address})
	</insert>
	这里的#{}是OGNL表达式：
		它是 apache 提供的一种表达式语言， 全称是：
		Object Graphic Navigation Language 对象图导航语言
		它是按照一定的语法格式来获取数据的。
		语法格式就是使用 #{对象.对象}的方式
		#{user.username}它会先去找 user 对象，然后在 user 对象中找到 username 属性，并调用getUsername()方法把值取出来。
		但是我们在 parameterType 属性上指定了实体类名称，所以可以省略 user.而直接写 username。
	注意：
		在mybatis实现增删改时一定要去控制事务的提交，可以使用:session.commit();来实现事务提交。
	获取当前插入的自增长的主键值：
		新增用户后， 同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，
		所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。
		可以使用sql语句：select last_insert_id();
		在映射文件中可以做如下配置：
		<insert id="saveUser" parameterType="cn.figo.domain.User">
			<!-- 配置插入操作后，获取插入数据的id -->
			<selectKey keyProperty="userId" keyColumn="id" resultType="int" order="AFTER">
				select last_insert_id();
			</selectKey>
			insert into user(username,address,sex,birthday)values(#{userName},#{userAddress},#{userSex},#{userBirthday});
		</insert>
3、	
	<!-- 更新用户 -->
    <update id="updateUser" parameterType="cn.figo.domain.User">
        update user set username=#{userName},address=#{userAddress},sex=#{userSex},birthday=#{userBirthday} where id=#{userId}
    </update>
	如果在parameterType属性中不想使用那么长的全限定类名，我们可以在主配置文件SqlMapConfig.xml中对POJO类做别名配置：
		<!--使用typeAliases配置别名，它只能配置domain中类的别名 -->
		<typeAliases>
			<!--typeAlias用于配置别名。type属性指定的是实体类全限定类名。alias属性指定别名，当指定了别名就不再区分大小写 
			<typeAlias type="com.itheima.domain.User" alias="user"></typeAlias>-->

			<!-- 用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写-->
			<package name="cn.figo.domain"></package>
		</typeAliases>
	这样配置后，我们在 parameterType 属性中，就可以使用：user或者UsEr等等都可以了。
	对于java中的基本数据类型，使用int、java.lang.Integer、INT都可以。
	基本类型和String我们可以直接写类型名称，也可以使用包名.类名的方式 。
4、
	<!-- 删除用户 -->
	<delete id="deleteUser" parameterType="java.lang.Integer">
		delete from user where id = #{uid}
	</delete>
5、
	<!-- 根据名称模糊查询 -->
	<select id="findByName" resultType="com.itheima.domain.User" parameterType="String">
		select * from user where username like #{username}
	</select>
	对于模糊查询，传入的参数应该加通配符:
	/**
	 * 测试模糊查询操作
	 */
	@Test
	public void testFindByName(){
		//5.执行查询一个方法
		List<User> users = userDao.findByName("%王%");
		for(User user : users){
			System.out.println(user);
		}
	}
	模糊查询的另一种实现：这种方法本质上是sql语句的拼接方式实现的，因此不常用
		<select id="findByName" parameterType="string" resultType="com.itheima.domain.User">
			select * from user where username like '%${value}%'
		</select>
		这样我们在查询测试类中就不需要加通配符了;
		List<User> users = userDao.findByName("%王%");
	ONGL中的#和$：
		#{}表示一个占位符号
		通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，
		#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类
		型值， #{}括号中可以是 value 或其它名称。
		${}表示拼接 sql 串
		通过${}可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换， ${}可以接收简
		单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值， ${}括号中只能是 value。
6、
	聚合函数的查询：
	<!-- 获取用户的总记录条数 -->
    <select id="findTotal" resultType="int">
        select count(id) from user;
    </select>
7、
以上我们POJO类的属性名和数据库的字段名相同，但对于二者不同的情况，我们可以配置resultMap来解决
	resultMap标签中的id自定义，type为POJO类名，由于我们在主配置文件中使用标签typeAliases给包中的类起了别名，因此，我们可以无视大小写。
	result标签中的属性property为POJO类中的属性名，column为数据库中的字段名
	<!-- 配置 查询结果的列名和实体类的属性名的对应关系 -->
    <resultMap id="userMap" type="uSeR">
        <!-- 主键字段的对应 -->
        <id property="userId" column="id"></id>
        <!--非主键字段的对应-->
        <result property="userName" column="username"></result>
        <result property="userAddress" column="address"></result>
        <result property="userSex" column="sex"></result>
        <result property="userBirthday" column="birthday"></result>
    </resultMap>
	然后我们在需要用到resultType="com.itheima.domain.User"的地方，直接换为resultMap="userMap"即可
8、
主配置文件SqlMapConfig.xml中配置的内容和顺序：
	-properties（属性）
		--property
	-settings（全局配置参数）
		--setting
	-typeAliases（类型别名）
		--typeAliase
		--package
	-typeHandlers（类型处理器）
	-objectFactory（对象工厂）
	-plugins（插件）
	-environments（环境集合属性对象）
		--environment（环境子属性对象）
			---transactionManager（事务管理）
			---dataSource（数据源）
	-mappers（映射器）
		--mapper
		--package
9、
主配置文件SqlMapConfig.xml中的标签properties
	对于数据库连接信息，我们现在上方的properties标签中定义好，然后在下方的environments标签中引用即可
	<properties>
		<property name="driver" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/ssm_mybatis"></property>
        <property name="username" value="root"></property>
        <property name="password" value="123456"></property>
    </properties>
	然后在下方引用：
	<environments default="mysql">
        <!-- 配置mysql的环境-->
        <environment id="mysql">
            <!-- 配置事务 -->
            <transactionManager type="JDBC"></transactionManager>
            <!--配置连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"></property>
                <property name="url" value="${url}"></property>
                <property name="username" value="${username}"></property>
                <property name="password" value="${password}"></property>
            </dataSource>
        </environment>
    </environments>
	还可以在properties标签中引用外部的jdbcConfig.properties配置文件
	<properties url="file:///D:/1_Code/java/javaSSM/mybatis_crud/src/main/resources/jdbcConfig.properties">
    </properties>
	在下方引用：
	<environments default="mysql">
        <!-- 配置mysql的环境-->
        <environment id="mysql">
            <!-- 配置事务 -->
            <transactionManager type="JDBC"></transactionManager>
            <!--配置连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"></property>
                <property name="url" value="${jdbc.url}"></property>
                <property name="username" value="${jdbc.username}"></property>
                <property name="password" value="${jdbc.password}"></property>
            </dataSource>
        </environment>
    </environments>
	其中jdbcConfig.properties中的内容为：
	jdbc.driver=com.mysql.jdbc.Driver
	jdbc.url=jdbc:mysql://localhost:3306/ssm_mybatis?useUnicode=true&characterEncoding=utf-8
	jdbc.username=root
	jdbc.password=123456
10、
	配置映射文件的位置也可以直接指定包名：
	<!-- 配置映射文件的位置 -->
    <mappers>
        <!--<mapper resource="com/itheima/dao/IUserDao.xml"></mapper>-->
		<!--<mapper class="com.itheima.dao.IUserDao"></mapper>-->
        <!-- package标签是用于指定dao接口所在的包,当指定了之后就不需要在写mapper以及resource或者class了 -->
        <package name="cn.figo.dao"></package>
    </mappers>
11、
关于测试类，如果在每次测试前和测试后，都需要执行一些固定操作，则可以使用@Before和@After注解，
实现每个测试方法执行前后都运行用这两个注解修饰的init和destroy方法
public class MybatisTest {

    private InputStream in;
    private SqlSession sqlSession;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行
    public void init()throws Exception{
        //1.读取配置文件，生成字节输入流
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.获取SqlSessionFactory
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.获取SqlSession对象
        sqlSession = factory.openSession();
        //4.获取dao的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destroy()throws Exception{
        //提交事务
        sqlSession.commit();
        //6.释放资源
        sqlSession.close();
        in.close();
    }

    /**
     * 测试查询所有
     */
    @Test
    public void testFindAll(){
        //5.执行查询所有方法
        List<User> users = userDao.findAll();
        for(User user : users){
            System.out.println(user);
        }

    }
}

mybatis中的连接池
	mybatis连接池提供了3种方式的配置：
		配置的位置：
			主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。
		type属性的取值：
			POOLED	 采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现
			UNPOOLED 采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。
			JNDI	 采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。
				 注意：如果不是web或者maven的war工程，是不能使用的。
				 tomcat服务器，采用连接池是dbcp连接池。

mybatis中if、where、forecah标签的使用
1、if标签
	在IUserDao.xml加标签，在IUserDao.java和MybatisTest.java加方法
	<!-- if 标签的使用-->
    <select id="findUserByCondition" parameterType="user" resultMap="userMap">
        select * from user where 1=1
        <if test="userName!=null and userName != '' ">
            and username like #{userName}
        </if>
        <if test="userAddress != null">
            and address like #{userAddress}
        </if>
    </select>
	
	/**
     * 条件查询
     * @param user
     * @return
     */
    List<User> findUserByCondition(User user);
	
	/**
     * if标签和where标签的使用
     */
    @Test
    public void testFindUserByCondition(){

        User user = new User();
        user.setUserName("%王%");
        //user.setUserAddress("%顺义%");
        //5.执行查询一个方法
        List<User> users = userDao.findUserByCondition(user);
        for(User u : users){
            System.out.println(u);
        }
    }
2、where标签
	<!-- where 标签的使用-->
	<select id="findUserByCondition" parameterType="user" resultMap="userMap">
        select * from user
        <where>
            <if test="userName!=null and userName != '' ">
                and username like #{userName}
            </if>
            <if test="userAddress != null">
                and address like #{userAddress}
            </if>
        </where>
    </select>
3、foreach标签的使用
	<!-- foreach标签的使用，根据queryvo中的Id集合实现查询用户列表 -->
    <!-- SELECT * FROM USERS WHERE id IN (41,46,51) -->
    <select id="findUserInIds" resultMap="userMap" parameterType="queryvo">
        <!--select * from user -->
        <include refid="defaultUser"></include>
        <where>
            <if test="ids != null and ids.size()>0">
                <foreach collection="ids" open="and id in (" close=")" item="uid" separator=",">
                    #{uid}
                </foreach>
            </if>
        </where>
    </select>
	
	/**
     * 根据queryvo中提供的id集合，查询用户信息
     * @param vo
     * @return
     */
    List<User> findUserInIds(QueryVo vo);
	
	/**
     * 测试foreach标签的使用
     */
    @Test
    public void testFindInIds(){
        QueryVo vo = new QueryVo();
        List<Integer> list = new ArrayList<Integer>();
        list.add(41);
        list.add(46);
        list.add(51);
        vo.setIds(list);

        //5.执行查询所有方法
        List<User> users = userDao.findUserInIds(vo);
        for(User user : users){
            System.out.println(user);
        }
    }
4、include和sql标签
	<!-- 抽取重复的sql语句-->
    <sql id="defaultUser">
        select * from user
    </sql>
	
	<select id="findAll" resultMap="userMap">
        <include refid="defaultUser"></include>
    </select>

mybatis多表查询
1、一对一
	比如User表和Account表，一个用户可以对应多个账户，所以是一对多，而一个账户只能对应一个用户，因此是一对一。
	多对一其实也就是一对一，虽然有多个账户，但是一个账户只有一个用户，sql语句为：
	select u.*,a.id as aid,a.uid,a.money from account a , user u where u.id = a.uid;
	1.1 如果我们要实现查询结果中，既有账户信息又有用户的用户名和地址的信息，最简单的方法是，写一个Account的子类：
		public class AccountUser extends Account {
			private String username;
			private String address;

			public String getUsername() {
				return username;
			}

			public void setUsername(String username) {
				this.username = username;
			}

			public String getAddress() {
				return address;
			}

			public void setAddress(String address) {
				this.address = address;
			}

			@Override
			public String toString() {
				return super.toString()+"        AccountUser{" +
						"username='" + username + '\'' +
						", address='" + address + '\'' +
						'}';
			}
		}
	然后在IAccountDao.xml中进行配置：
		<!--查询所有账户同时包含用户名和地址信息-->
		<select id="findAllAccount" resultType="accountuser">
			select a.*,u.username,u.address from account a , user u where u.id = a.uid;
		</select>
	在测试类中测试：
		/**
		 * 测试查询所有账户，同时包含用户名称和地址
		 */
		@Test
		public void testFindAllAccountUser(){
			List<AccountUser> aus = accountDao.findAllAccount();
			for(AccountUser au : aus){
				System.out.println(au);
			}
		}
	1.2 <association>标签
	一对一的方法最好不要向1.1那么写，而应该：从表实体(Account)应该包含一个主表实体(User)的对象引用
		public class Account implements Serializable {
			private Integer aid;
			private Integer uid;
			private Double money;
			//从表实体应该包含一个主表实体的对象引用
			private User user;
		}
		然后我们需要在IAccountDao.xml中定义封装account和user的一对一的resultMap：
		<!-- 定义封装account和user的resultMap -->
		<resultMap id="accountUserMap" type="account">
			<id property="aid" column="aid"></id>
			<result property="uid" column="uid"></result>
			<result property="money" column="money"></result>
			<!-- 一对一的关系映射：配置封装user的内容-->
			<association property="user" column="uid" javaType="user">
				<id property="userId" column="id"></id>
				<result property="userName" column="username"></result>
				<result property="userAddress" column="address"></result>
				<result property="userSex" column="sex"></result>
				<result property="userBirthday" column="birthday"></result>
			</association>
		</resultMap>
		然后写查询语句：
		<!-- 查询所有 -->
		<select id="findAll" resultMap="accountUserMap">
			select u.*,a.aid as aid,a.uid,a.money from account a , user u where u.id = a.uid;
		</select>
		在测试类中测试：
		/**
		 * 测试查询所有
		 */
		@Test
		public void testFindAll(){
			List<Account> accounts = accountDao.findAll();
			for(Account account : accounts){
				System.out.println("--------每个account的信息------------");
				System.out.println(account);
				System.out.println(account.getUser());
			}
		}
2.多对一： <collection>标签
	主表实体(User)应该包含从表实体(Account)的集合引用：
		public class User implements Serializable {
			private Integer userId;
			private String userName;
			private String userAddress;
			private String userSex;
			private Date userBirthday;
			//一对多关系映射：主表实体应该包含从表实体的集合引用
			private List<Account> accounts;
		}
	然后我们需要在IUserDao.xml中定义封装user和account的一对多的resultMap：
		<!-- 定义User的resultMap-->
		<resultMap id="userAccountMap" type="user">
			<!-- 主键字段的对应 -->
			<id property="userId" column="id"></id>
			<!--非主键字段的对应-->
			<result property="userName" column="username"></result>
			<result property="userAddress" column="address"></result>
			<result property="userSex" column="sex"></result>
			<result property="userBirthday" column="birthday"></result>
			<!-- 配置user对象中accounts集合的映射 -->
			<collection property="accounts" ofType="account">
				<id property="aid" column="aid"></id>
				<result property="uid" column="uid"></result>
				<result property="money" column="money"></result>
			</collection>
		</resultMap>
	然后写查询语句：
		<!-- 查询所有 user的一对多的信息 -->
		<select id="findUserAccount" resultMap="userAccountMap">
			select * from user u left outer join account a on u.id = a.uid
		</select>
	在测试类中测试：
		 /**
		 * 测试user一对多查询所有
		 */
		@Test
		public void testFindUserAccount(){
			List<User> users = userDao.findUserAccount();
			for(User user : users){
				System.out.println("--------每个user的信息------------");
				System.out.println(user);
				System.out.println(user.getAccounts());
			}
		}
	我在实际学习中测试发现，对于这种关联的实体类，如果不同的数据库表中的id字段名如果相同的话，
	有可能其中一个表的id显示为null，所以要确保不同的表的id的字段名最好要区分开。比如，我原来的user表中的主键叫id，
	account中的主键也叫id，那么这时，mybatis一对多查询到的结果中，account的id显示为null，如果我该表后，将account的表的
	主键改为 aid，那么mybatis显示结果正常。

3、多对多
	建立两张表：用户表，角色表
	让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。
	3.1 当我们查询所有角色时，可以同时得到角色的所赋予的用户信息
		一个Role可以赋予给多个User，因此在Role的实体类中包含User的集合引用：
		public class Role implements Serializable {
			private Integer roleId;
			private String roleName;
			private String roleDesc;
			//多对多的关系映射：一个角色可以赋予多个用户
			private List<User> users;
		}
		然后我们需要在IRoleDao.xml中定义封装role和user的一对多的resultMap：
		<!--定义role表的ResultMap-->
		<resultMap id="roleMap" type="role">
			<id property="roleId" column="rid"></id>
			<result property="roleName" column="role_name"></result>
			<result property="roleDesc" column="role_desc"></result>
			<collection property="users" ofType="user">
				<id property="userId" column="id"></id>
				<result property="userName" column="username"></result>
				<result property="userAddress" column="address"></result>
				<result property="userSex" column="sex"></result>
				<result property="userBirthday" column="birthday"></result>
			</collection>
		</resultMap>
		然后写查询语句：role先左关联user_role，再左关联user
		<!--查询所有-->
		<select id="findAll" resultMap="roleMap">
		   select r.id as rid,r.role_name,r.role_desc,u.* from role r
		   left outer join user_role ur  on r.id = ur.rid
		   left outer join user u on u.id = ur.uid
		</select>
		在测试类中测试：
		/**
		 * 测试查询所有
		 */
		@Test
		public void testFindAll(){
			List<Role> roles = roleDao.findAll();
			for(Role role : roles){
				System.out.println("---每个角色的信息----");
				System.out.println(role);
				System.out.println(role.getUsers());
			}
		}
	3.2 当我们查询所有用户时，可以同时得到用户所包含的角色信息
		一个User可以有多个Role，因此在User的实体类中包含Role的集合引用：
		public class User implements Serializable {
			private Integer userId;
			private String userName;
			private String userAddress;
			private String userSex;
			private Date userBirthday;
			//一对多关系映射：主表实体应该包含从表实体的集合引用
			private List<Account> accounts;
			//多对多的关系映射：一个用户可以具备多个角色
			private List<Role> roles;
		}
		然后我们需要在IUserDao.xml中定义封装user和role的一对多的resultMap：
		<!-- 定义User的resultMap-->
		<resultMap id="userRoleMap" type="user">
			<id property="userId" column="id"></id>
			<result property="userName" column="username"></result>
			<result property="userAddress" column="address"></result>
			<result property="userSex" column="sex"></result>
			<result property="userBirthday" column="birthday"></result>
			<!-- 配置角色集合的映射 -->
			<collection property="roles" ofType="role">
				<id property="roleId" column="rid"></id>
				<result property="roleName" column="role_name"></result>
				<result property="roleDesc" column="role_desc"></result>
			</collection>
		</resultMap>
		然后写查询语句：user先左关联user_role，再左关联role
		<!-- 查询所有 -->
		<select id="findUserRole" resultMap="userRoleMap">
			select u.*,r.id as rid,r.role_name,r.role_desc from user u
			 left outer join user_role ur  on u.id = ur.uid
			 left outer join role r on r.id = ur.rid
		</select>
		在测试类中测试：
		/**
		 * 测试多对多查询所有 user
		 */
		@Test
		public void testFindUserRole(){
			List<User> users = userDao.findUserRole();
			for(User user : users){
				System.out.println("-----每个用户的信息------");
				System.out.println(user);
				System.out.println(user.getRoles());
			}
		}

mybatis延迟加载，一、二级缓存
延迟加载：在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）
立即加载：不管用不用，只要一调用方法，马上发起查询。
比如这样的加载时机：
	在查询用户时，用户下的账户信息是 什么时候使用，什么时候查询，这就是延迟加载。
	在查询账户时，账户的所属用户信息随着账户查询时一起查询，这就是立即加载。
在对应的四种表关系中：一对多，多对一，一对一，多对多
	一对多，多对多：通常情况下我们都是采用延迟加载。
	多对一，一对一：通常情况下我们都是采用立即加载。
与延迟加载相关的属性：
	lazyLoadingEnabled：延迟加载的全局开关。默认为 true
	aggressiveLazyLoading：打开后立即加载，否则将按需加载，默认为 false
一对一延迟加载：
	在SqlMapConfig.xml中进行如下配置：
		<settings>
			<!-- 开启Mybatis支持延迟加载 -->
			<setting name="lazyLoadingEnabled" value="true"/>
			<setting name="aggressiveLazyLoading" value="false"/>
		</settings>
	然后对IAccountDao.xml中一对一关联查询的resultMap进行修改：
		<resultMap id="accountUserMap" type="account">
			<id property="id" column="id"></id>
			<result property="uid" column="uid"></result>
			<result property="money" column="money"></result>
			<!-- 一对一的关系映射：配置封装user的内容
			select属性指定的内容：查询用户的唯一标识：
			column属性指定的内容：用户根据id查询时，所需要的参数的值
			-->
			<association property="user" column="uid" javaType="user" select="cn.figo.dao.IUserDao.findById"></association>
		</resultMap>
	这时select标签中的sql语句就不需要进行关联查询了，因为关联查询一次性就把account和user信息都查询出来了。
	resultMap中的select会根据account查出的结果，再使用uid进行IUserDao.findById查询。
		<!-- 查询所有 -->
		<select id="findAll" resultMap="accountUserMap">
			select * from account
		</select>
多对一的延迟加载：
	对IUserDao.xml中一对一关联查询的resultMap进行修改：
		<resultMap id="userAccountLazyMap" type="user">
			<id property="userId" column="id"></id>
			<result property="userName" column="username"></result>
			<result property="userAddress" column="address"></result>
			<result property="userSex" column="sex"></result>
			<result property="userBirthday" column="birthday"></result>
			<!-- 配置user对象中accounts集合的映射 -->
			<collection property="accounts" ofType="account" select="cn.figo.dao.IAccountDao.findAccountByUidLazy" column="id"></collection>
		</resultMap>
	配置sql：
		<select id="findAllLazyMulti" resultMap="userAccountLazyMap">
			select * from user;
		</select>
	在IAccountDao.xml中配置findAccountByUidLazy方法的sql
		<select id="findAccountByUidLazy" resultType="account">
			select * from account where uid = #{uid}
		</select>
Mybatis中的缓存：
什么是缓存
	存在于内存中的临时数据。
为什么使用缓存
	减少和数据库的交互次数，提高执行效率。
什么样的数据能使用缓存，什么样的数据不能使用
	适用于缓存：
		经常查询并且不经常改变的。
		数据的正确与否对最终结果影响不大的。
	不适用于缓存：
		经常改变的数据
		数据的正确与否对最终结果影响很大的。
		例如：商品的库存，银行的汇率，股市的牌价。
Mybatis中的一级缓存和二级缓存
	一级缓存：
		它指的是Mybatis中SqlSession对象的缓存。
		当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。
		该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中
		查询是否有，有的话直接拿出来用。
		当SqlSession对象消失时，mybatis的一级缓存也就消失了。
	二级缓存:
		它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享二级缓存。
		二级缓存的使用步骤：
			第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）
			第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）
			第三步：让当前的操作支持二级缓存（在select标签中配置）	
一级缓存：
	/**
	 * 测试一级缓存
	 */
	@Test
	public void testFirstLevelCache(){
		User user1 = userDao.findById(41);
		System.out.println(user1);

		User user2 = userDao.findById(41);
		System.out.println(user2);

		System.out.println(user1 == user2);
	}
这里一级缓存是默认打开的，我们同时发起两次请求，拿到的对象是同一个。
注释掉toString方法后，地址都是同一个，== 的结果也是 true，并且看控制台发现只发起了一次查询。
当我们第一次查询结束后，关闭sqlSession后重新产生sqlSession后，由于一级缓存消失，最终两次查询发起了两次请求：
	User user1 = userDao.findById(41);
	System.out.println(user1);
	sqlSession.close();
	//再次获取SqlSession对象
	sqlSession = factory.openSession();
	userDao = sqlSession.getMapper(IUserDao.class);
	User user2 = userDao.findById(41);
	System.out.println(user2);
	System.out.println(user1 == user2);
sqlSession除了可以通过sqlSession.close();清空一级缓存外，还可以通过sqlSession.clearCache();来清空缓存

二级缓存：
它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享二级缓存。
让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）
	<setting name="cacheEnabled" value="true"/>
让当前的映射文件支持二级缓存（在IUserDao.xml中配置）
	<cache/>
让当前的操作支持二级缓存（在select标签中配置）
	<select id="findById" parameterType="INT" resultMap="userMap" useCache="true">
        select * from user where id = #{uid}
    </select>
写测试方法：第一次查询完和第二次查询完都关闭sqlSession缓存
    /**
     * 测试二级缓存
     */
    @Test
    public void testSecondLevelCache(){
        SqlSession sqlSession1 = factory.openSession();
        IUserDao dao1 = sqlSession1.getMapper(IUserDao.class);
        User user1 = dao1.findById(41);
        System.out.println(user1);
        sqlSession1.close();//一级缓存消失

        SqlSession sqlSession2 = factory.openSession();
        IUserDao dao2 = sqlSession2.getMapper(IUserDao.class);
        User user2 = dao2.findById(41);
        System.out.println(user2);
        sqlSession2.close();

        System.out.println(user1 == user2);
    }
我们最终发现，两次查询值发起了一次sql，但是两次查到的结果的user并不是同一个对象，地址值不同，
这是因为二级缓存中存储的是数据而不是对象，虽然两次查询只发起一次sql，但第二次返回的数据重新
封装到另一个user对象中了，但本质上还是利用了以及缓存，只进行了一次sql操作。

mybatis 注解开发
	@Insert:实现新增
	@Update:实现更新
	@Delete:实现删除
	@Select:实现查询
	@Result:实现结果集封装
	@Results:可以与@Result 一起使用，封装多个结果集
	@ResultMap:实现引用@Results 定义的封装
	@One:实现一对一结果集封装
	@Many:实现一对多结果集封装
	@SelectProvider: 实现动态 SQL 映射
	@CacheNamespace:实现注解二级缓存的使用
	
// 使用注解进行单表 CRUD
public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    @Select("select * from user")
    List<User> findAll();

    /**
     * 保存用户
     * @param user
     */
    @Insert("insert into user(username,address,sex,birthday)values(#{username},#{address},#{sex},#{birthday})")
    void saveUser(User user);

    /**
     * 更新用户
     * @param user
     */
    @Update("update user set username=#{username},sex=#{sex},birthday=#{birthday},address=#{address} where id=#{id}")
    void updateUser(User user);

    /**
     * 删除用户
     * @param userId
     */
    @Delete("delete from user where id=#{id} ")
    void deleteUser(Integer userId);

    /**
     * 根据id查询用户
     * @param userId
     * @return
     */
    @Select("select * from user  where id=#{id} ")
    User findById(Integer userId);

    /**
     * 根据用户名称模糊查询
     * @param username
     * @return
     */
    @Select("select * from user where username like #{username} ")
//    @Select("select * from user where username like '%${value}%' ")
    List<User> findUserByName(String username);

    /**
     * 查询总用户数量
     * @return
     */
    @Select("select count(*) from user ")
    int findTotalUser();
}

// 编写测试类
public class AnnotationCRUDTest {

    private InputStream in;
    private SqlSessionFactory factory;
    private SqlSession session;
    private IUserDao userDao;

    @Before
    public  void init() throws Exception{
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        factory = new SqlSessionFactoryBuilder().build(in);
        session = factory.openSession();
        userDao = session.getMapper(IUserDao.class);
    }

    @After
    public  void destroy() throws  Exception{
        session.commit();
        session.close();
        in.close();
    }


    @Test
    public void testSave(){
        User user = new User();
        user.setUsername("mybatis annotation");
        user.setAddress("北京市昌平区");

        userDao.saveUser(user);
    }

    @Test
    public void testUpdate(){
        User user = new User();
        user.setId(53);
        user.setUsername("mybatis annotation update");
        user.setAddress("北京市海淀区");
        user.setSex("男");
        user.setBirthday(new Date());

        userDao.updateUser(user);
    }

    @Test
    public void testDelete(){
        userDao.deleteUser(51);
    }

    @Test
    public void testFindOne(){
        User user = userDao.findById(53);
        System.out.println(user);

    }

    @Test
    public  void testFindByName(){
        List<User> users = userDao.findUserByName("%mybatis%");
//        List<User> users = userDao.findUserByName("mybatis");
        for(User user : users){
            System.out.println(user);
        }
    }

    @Test
    public  void testFindTotal(){
        int total = userDao.findTotalUser();
        System.out.println(total);
    }
}

如果实体类属性名和数据库字段名不一致，需要加 Results
@Results(id="userMap",value={
            @Result(id=true,column = "id",property = "userId"),
            @Result(column = "username",property = "userName"),
            @Result(column = "address",property = "userAddress"),
            @Result(column = "sex",property = "userSex"),
            @Result(column = "birthday",property = "userBirthday")
    })
@Select("select * from user")
List<User> findAll();


@Select("select * from user  where id=#{id} ")
@ResultMap("userMap")
User findById(Integer userId);


Spring

spring概述：
Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）
和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 SpringMVC 和
持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多
著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。

spring优势：
方便解耦，简化开发：通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。
AOP 编程的支持：通过 Spring 的 AOP 功能，方便进行面向切面的编程
声明式事务的支持
方便程序的测试
方便集成各种优秀框架：提供了对各种优秀框架（Struts、Hibernate、Hessian、 Quartz等）的直接支持。
降低 JavaEE API 的使用难度：Spring 对 JavaEE API（如 JDBC、 JavaMail、远程调用等）进行了薄薄的封装层
Java 源码是经典学习范例：各种设计模式

程序的耦合：
耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调
用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关
系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差。
软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是高内聚低耦合。
耦合分类：
（1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另
一个模块时，这样的耦合被称为内容耦合。
（2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大
量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。
（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传
递该全局变量的信息，则称之为外部耦合。
（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进
行适当的动作，这种耦合被称为控制耦合。
（5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间
存在一个标记耦合。
（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形
式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另
一些模块的输入数据。
（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。


控制反转 IOC：
在bean.xml中加入bean标签
    <!--把对象的创建交给spring来管理-->
    <bean id="accountService" class="cn.figo.service.impl.AccountServiceImpl"></bean>
    <bean id="accountDao" class="cn.figo.dao.impl.AccountDaoImpl"></bean>
然后可以获取spring的Ioc核心容器，并根据id获取bean对象
	// 获取核心容器对象
	ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
	// 根据id获取bean对象
	IAccountService accountService = (IAccountService) ac.getBean("accountService");
	IAccountDao accountDao = (IAccountDao) ac.getBean("accountDao");

ApplicationContext的三个常用实现类：
	ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了。(更常用)
	FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件(必须有访问权限）
	AnnotationConfigApplicationContext：它是用于读取注解创建容器的

核心容器的两个接口
	ApplicationContext: 单例对象适用，实际开发通常采用此接口
		它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。
	BeanFactory: 多例对象使用
		它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。
		
spring对bean的管理
第一种方式：使用默认构造函数创建。
	在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。
	采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。
第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）
第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)

bean的作用范围调整，bean标签的scope属性：
作用：用于指定bean的作用范围
取值： 常用的就是单例的和多例的
	singleton：单例的（默认值）
	prototype：多例的
	request：作用于web应用的请求范围
	session：作用于web应用的会话范围
	global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session

bean对象的生命周期
单例对象：单例对象的生命周期和容器相同
	出生：当容器创建时对象出生
	活着：只要容器还在，对象一直活着
	死亡：容器销毁，对象消亡
多例对象
	出生：当我们使用对象时spring框架为我们创建
	活着：对象只要是在使用过程中就一直活着。
	死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收
	
依赖注入：Dependency Injection
IOC的作用：降低程序间的耦合（依赖关系）
依赖关系的管理：以后都交给spring来维护
	在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明
依赖关系的维护：就称之为依赖注入。

能注入的数据：有三类
	基本类型和String
	其他bean类型（在配置文件中或者注解配置过的bean）
	复杂类型/集合类型

注入的方式：有三种
第一种：使用构造函数提供
构造函数注入：
	使用的标签:constructor-arg
	标签出现的位置：bean标签的内部
	标签中的属性
		type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型
		index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始
		name：用于指定给构造函数中指定名称的参数赋值
		=============以上三个用于指定给构造函数中哪个参数赋值===============================
		value：用于提供基本类型和String类型的数据
		ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象

	优势：
		在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。
	弊端：
		改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。
第二种：使用set方法提供
set方法注入，更常用的方式
	涉及的标签：property
	出现的位置：bean标签的内部
	标签的属性
		name：用于指定注入时所调用的set方法名称
		value：用于提供基本类型和String类型的数据
		ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象
	优势：
		创建对象时没有明确的限制，可以直接使用默认构造函数
	弊端：
		如果有某个成员必须有值，则获取对象是有可能set方法没有执行。
	复杂类型的注入/集合类型的注入
        用于给List结构集合注入的标签：
            list array set
        用于个Map结构集合注入的标签:
            map  props
        结构相同，标签可以互换
第三种：使用注解提供
	首先在配置文件中设置：告知spring在创建容器时要扫描的包，
	配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中
	<context:component-scan base-package="cn.figo"></context:component-scan>
四类注解：
用于创建对象的
	他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的
	1、Component:
		作用：用于把当前类对象存入spring容器中
		属性：
		value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。
	2、Controller：一般用在表现层
	3、Service：一般用在业务层
	4、Repository：一般用在持久层
	以上三个注解他们的作用和属性与Component是一模一样。
	他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰
用于注入数据的
	他们的作用就和在xml配置文件中的bean标签中写一个<property>标签的作用是一样的
	5、Autowired:
		作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功
		如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。
		如果Ioc容器中有多个类型匹配时：
		出现位置：
		可以是变量上，也可以是方法上
		细节：
		在使用注解注入时，set方法就不是必须的了。
	6、Qualifier:
		作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以（稍后我们讲）
		属性：
		value：用于指定注入bean的id。
	7、Resource
		作用：直接按照bean的id注入。它可以独立使用
		属性：
		name：用于指定bean的id。
	以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。
	另外，集合类型的注入只能通过XML来实现。
	8、Value
		作用：用于注入基本类型和String类型的数据
		属性：
		value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）
			  SpEL的写法：${表达式}
用于改变作用范围的
	他们的作用就和在bean标签中使用scope属性实现的功能是一样的
	9、Scope
		作用：用于指定bean的作用范围
		属性：
		value：指定范围的取值。常用取值：singleton prototype
和生命周期相关 了解
	他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的
	10、PreDestroy
		作用：用于指定销毁方法
	11、PostConstruct
		作用：用于指定初始化方法

spring中的新注解
1、Configuration
    作用：指定当前类是一个配置类
    细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。
2、ComponentScan
	作用：用于通过注解指定spring在创建容器时要扫描的包
	属性：
	value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。
		我们使用此注解就等同于在xml中配置了:
			 <context:component-scan base-package="com.itheima"></context:component-scan>
3、Bean
	作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中
	属性:
		name:用于指定bean的id。当不写时，默认值是当前方法的名称
	细节：
	当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。
	查找的方式和Autowired注解的作用是一样的
4、Import
	作用：用于导入其他的配置类
	属性：
	value：用于指定其他配置类的字节码。
		当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类
5、PropertySource
	作用：用于指定properties文件的位置
	属性：
	value：指定文件的名称和路径。
		关键字：classpath，表示类路径下

junit整合spring的注解：
1、应用程序的入口为main方法，junit没有mian方法也能够运行，因为junit集成了一个main方法，
	该方法就会判断当前测试类中哪些方法有 @Test注解，junit就让有Test注解的方法执行。
2、在执行测试方法时，junit根本不知道我们是不是使用了spring框架
	所以也就不会为我们读取配置文件/配置类创建spring核心容器
3、使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的main方法，
	使用 @RunWith(SpringJUnit4ClassRunner.class)
4、告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置
	注解：@ContextConfiguration(classes = SpringConfiguration.class)
	xml：@ContextConfiguration(locations = "classpath:bean.xml")

	
Aop：
动态代理：
特点：字节码随用随创建，随用随加载
作用：不修改源码的基础上对方法增强
分类：
	基于接口的动态代理
	基于子类的动态代理
基于接口的动态代理：
	涉及的类：Proxy
	提供者：JDK官方
	如何创建代理对象：
		使用Proxy类中的newProxyInstance方法
	创建代理对象的要求：
		被代理类最少实现一个接口，如果没有则不能使用
	newProxyInstance方法的参数：
		ClassLoader：类加载器
			它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。
		Class[]：字节码数组
			它是用于让代理对象和被代理对象有相同方法。固定写法。
		InvocationHandler：用于提供增强的代码
			它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
			此接口的实现类都是谁用谁写。
	InvocationHandler的实现类需要重写invoke()方法，
	作用：执行被代理对象的任何接口方法都会经过该方法
	方法参数的含义
		@param proxy   代理对象的引用
		@param method  当前执行的方法
		@param args    当前执行方法所需的参数
		@return        和被代理对象方法有相同的返回值
	基于接口的动态代理，要求被代理类必须实现接口，如果被代理类没有实现任何接口，那不能使用Proxy
基于子类的动态代理：
	涉及的类：Enhancer
	提供者：第三方cglib库
	如何创建代理对象：
		使用Enhancer类中的create方法
	创建代理对象的要求：
		被代理类不能是最终类
	create方法的参数：
		Class：字节码
			它是用于指定被代理对象的字节码。
		Callback：用于提供增强的代码
			它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
			此接口的实现类都是谁用谁写。
			我们一般写的都是该接口的子接口实现类：MethodInterceptor
	使用MethodInterceptor需要重写intercept()方法，该方法的参数及返回值为：
		@param proxy
		@param method
		@param args
			以上三个参数和基于接口的动态代理中invoke方法的参数是一样的
		@param methodProxy ：当前执行方法的代理对象

AOP术语
Joinpoint(连接点):
	所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。
Pointcut(切入点):
	所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。
Advice(通知/增强):
	所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。
	通知的类型： 前置通知,后置通知,异常通知,最终通知,环绕通知。
Introduction(引介):
	引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。
Target(目标对象):
	代理的目标对象。
Weaving(织入):
	是指把增强应用到目标对象来创建新的代理对象的过程。
	spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。
Proxy（代理） :
	一个类被 AOP 织入增强后，就产生一个结果代理类。
Aspect(切面):
	是切入点和通知（引介）的结合。

spring中基于XML的AOP配置步骤
1、把通知Bean也交给spring来管理
2、使用aop:config标签表明开始AOP的配置
3、使用aop:aspect标签表明配置切面
		id属性：是给切面提供一个唯一标识
		ref属性：是指定通知类bean的Id。
4、在aop:aspect标签的内部使用对应标签来配置通知的类型
	   我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知
	   aop:before：表示配置前置通知
			method属性：用于指定Logger类中哪个方法是前置通知
			pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强

	切入点表达式用于指定要增强哪一个方法
	切入点表达式的写法：
		关键字：execution(表达式)
		表达式：
			访问修饰符  返回值  包名.包名.包名...类名.方法名(参数列表)
		标准的表达式写法：
			public void com.itheima.service.impl.AccountServiceImpl.saveAccount()
		访问修饰符可以省略
			void com.itheima.service.impl.AccountServiceImpl.saveAccount()
		返回值可以使用通配符，表示任意返回值
			* com.itheima.service.impl.AccountServiceImpl.saveAccount()
		包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*.
			* *.*.*.*.AccountServiceImpl.saveAccount())
		包名可以使用..表示当前包及其子包
			* *..AccountServiceImpl.saveAccount()
		类名和方法名都可以使用*来实现通配
			* *..*.*()
		参数列表：
			可以直接写数据类型：
				基本类型直接写名称           int
				引用类型写包名.类名的方式   java.lang.String
			可以使用通配符表示任意类型，但是必须有参数
			可以使用..表示有无参数均可，有参数可以是任意类型
		全通配写法：
			* *..*.*(..)

		实际开发中切入点表达式的通常写法：
			切到业务层实现类下的所有方法
				* com.itheima.service.impl.*.*(..)
				
四种通知类型：前置通知、后置通知、异常通知、最终通知。
前置通知：在切入点方法执行之前执行
后置通知：在切入点方法正常执行之后执行。它和异常通知永远只能执行一个
异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个
最终通知：无论切入点方法是否正常执行它都会在其后面执行
以上四种通知中，最多只能执行三种，因为后置通知和异常通知是互斥的。
AOP四种通知类型的完整bean.xml如下
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 配置srping的Ioc,把service对象配置进来-->
    <bean id="accountService" class="cn.figo.service.impl.AccountServiceImpl"></bean>

    <!-- 配置Logger类 -->
    <bean id="logger" class="cn.figo.utils.Logger"></bean>

    <!--配置AOP-->
    <aop:config>
        <aop:pointcut id="pt1" expression="execution(* cn.figo.service.impl.*.*(..))"></aop:pointcut>
        <!--配置切面 -->
        <aop:aspect id="logAdvice" ref="logger">

            <!--配置前置通知：在切入点方法执行之前执行-->
            <aop:before method="beforePrintLog" pointcut-ref="pt1" ></aop:before>

             <!--配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个-->
            <aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"></aop:after-returning>

             <!--配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个-->
            <aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"></aop:after-throwing>

             <!--配置最终通知：无论切入点方法是否正常执行它都会在其后面执行-->
            <aop:after method="afterPrintLog" pointcut-ref="pt1"></aop:after>
        </aop:aspect>
    </aop:config>

</beans>

环绕通知：
	<aop:around method="aroundPringLog" pointcut-ref="pt1"></aop:around>
Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。
该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。
本质：spring中的环绕通知，是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。
环绕通知方法：
	public Object aroundPringLog(ProceedingJoinPoint pjp){
        Object rtValue = null;
        try{
            Object[] args = pjp.getArgs();//得到方法执行所需的参数

            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。前置");

            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）

            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。后置");

            return rtValue;
        }catch (Throwable t){
            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。异常");
            throw new RuntimeException(t);
        }finally {
            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。最终");
        }
    }
	
注解进行AOP配置
涉及的标签：
	<context:component-scan>:配置spring创建容器时要扫描的包
	<aop:aspectj-autoproxy>:开启AOP注解
涉及的注解：
	@Service("accountService")
	@Component("logger")
	@Aspect //表示当前类是一个切面类
	@Pointcut("execution(* cn.figo.service.impl.*.*(..))") //配置切入点表达式
	@Before("pt1()") //前置通知
	@AfterReturning("pt1()") //后置通知
	@AfterThrowing("pt1()") //异常通知
	@After("pt1()") //最终通知
	@Around("pt1()") //环绕通知

完全不使用xml配置AOP：
	@Configuration
	@ComponentScan(basePackages = "cn.figo")
	@EnableAspectJAutoProxy //开启AOP
	public class SpringConfiguration {
	}

事务控制：
事务并发情况下容易出现以下问题：
脏读（Dirty reads）： 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。
不可重复读（Nonrepeatable read）：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，
	对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
幻读（Phantom read）：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，
	但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
不可重复读侧重于修改，幻读侧重于新增或删除。
	
spring中基于XML的声明式事务控制配置步骤
1、配置事务管理器
2、配置事务的通知
		此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的
		使用tx:advice标签配置事务通知
			属性：
				id：给事务通知起一个唯一标识
				transaction-manager：给事务通知提供一个事务管理器引用
3、配置AOP中的通用切入点表达式
4、建立事务通知和切入点表达式的对应关系
5、配置事务的属性
	   是在事务的通知tx:advice标签的内部
	 
配置事务的属性 <tx:method> 在 <tx:advice>中的<tx:attributes>标签内配置
	isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。
	propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。
	read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。
	timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。
	rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。
	no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。
	 
<!-- 配置事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"></property>
</bean>

<!-- 配置事务的通知-->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
	<tx:attributes>
		<tx:method name="*" propagation="REQUIRED" read-only="false"/>
		<tx:method name="find*" propagation="SUPPORTS" read-only="true"></tx:method>
	</tx:attributes>
</tx:advice>

<!-- 配置aop-->
<aop:config>
	<!-- 配置切入点表达式-->
	<aop:pointcut id="pt1" expression="execution(* cn.figo.service.impl.*.*(..))"></aop:pointcut>
	<!--建立切入点表达式和事务通知的对应关系 -->
	<aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"></aop:advisor>
</aop:config>

spring中基于注解的声明式事务控制配置步骤
@Configuration // 声明spring配置类
@ComponentScan  // spring创建容器时要扫描的包
@Import  // 导入其他配置类
@PropertySource // 导入配置文件
@EnableTransactionManagement // 开启事务注解的支持
@Value  // 注入基本数据类型或String
@Autowired  // 自动注入
@Service // 将当前类交给spring管理
@Repository   // 将当前类交给spring管理
@Bean  // 用于把当前方法的返回值作为bean对象存入spring的ioc容器中
@Transactional 
可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，
同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。

编程式事务控制
需要借助事务模板对象，不常用，因为背离了AOP思想
<!--配置事务模板对象-->
<bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
	<property name="transactionManager" ref="transactionManager"></property>
</bean>
然后在service类的具体方法中，调用事务模板对象的execute()方法，该方法的参数是TransactionCallback对象，
因此需要创建匿名对象，并重写该实例的doInTransaction()方法，可以实现事务控制。
@Override
public Account findAccountById(Integer accountId) {
	return  transactionTemplate.execute(new TransactionCallback<Account>() {
		@Override
		public Account doInTransaction(TransactionStatus status) {
			return accountDao.findAccountById(accountId);
		}
	});
}



springMVC
在 B/S 架构中，系统标准的三层架构包括：表现层、业务层、持久层。
表现层：
	也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用 http协议请求web层，
	web 需要接收 http 请求，完成 http 响应。表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。
	表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。
	表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）
业务层：
	也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。 
	web 层依赖业务层，但是业务层不依赖 web 层。业务层在业务处理时可能会依赖持久层，
	如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制）
持久层：
	也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，
	数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。
	通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。
MVC 模型
MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，
是一种用于设计创建 Web 应用程序表现层的模式。 MVC 中每个部分各司其职：
Model（模型） ：
	通常指的就是我们的数据模型。作用一般情况下用于封装数据。
View（视图） ：
	通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。通常视图是依据模型数据创建的。
Controller（控制器） ：
	是应用程序中处理用户交互的部分。 作用一般就是处理程序逻辑的。
SpringMVC
SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架。
SpringMVC中的对象：
	前端控制器（DispatcherServlet）
	请求到处理器映射（HandlerMapping）
	处理器适配器（HandlerAdapter）
	视图解析器（ViewResolver）
	处理器或页面控制器（Controller）
	验证器（ Validator）
	命令对象（Command 请求参数绑定到的对象就叫命令对象）
	表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。
SpringMVC 和 Struts2 的优略分析
共同点：
	它们都是表现层框架，都是基于 MVC 模型编写的。
	它们的底层都离不开原始 ServletAPI。
	它们处理请求的机制都是一个核心控制器。
区别：
	Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter
	Spring MVC 是基于方法设计的，而 Struts2 是基于类， Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。
	Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便
	Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提升，尤其是 struts2 的表单标签，远没有 html 执行效率高。

RequestMapping注解
RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系
RequestMapping注解可以作用在方法和类上
	1. 作用在类上：第一级的访问目录
	2. 作用在方法上：第二级的访问目录
	3. 细节：路径可以不编写 / 表示应用的根目录开始
RequestMapping的属性
	1. path 指定请求路径的url
	2. value value属性和path属性是一样的
	3. mthod 指定该方法的请求方式
	4. params 指定限制请求参数的条件
	5. headers 发送的请求中必须包含的请求头
@RequestMapping(path = "/testRequestMapping", method = {RequestMethod.POST,RequestMethod.GET},params = {"username=tom"},headers = {"accept"})
	
	
请求参数的绑定
绑定机制
1. 表单提交的数据都是k=v格式的 username=haha&password=123
2. SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的
3. 要求：提交表单的name和参数的名称是相同的
支持的数据类型
1. 基本数据类型和字符串类型
2. 实体类型（JavaBean）
3. 集合数据类型（List、map集合等）
基本数据类型和字符串类型
1. 提交表单的name和参数的名称是相同的
2. 区分大小写
实体类型（JavaBean）
1. 提交表单的name和JavaBean中的属性名称需要一致
2. 如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如：address.name
给集合属性数据封装
JSP页面编写方式：list[0].属性

自定义类型转换器
比如User中有一个Date类型的属性date，前端传来的String类型的数据，
传入控制器后无法自动封装为Date类型，因此我们需要自定义类型转换器，然后在springmvc.xml中注册该转换器。



springMVC常用注解：

RequestParam注解
作用：把请求中的指定名称的参数传递给控制器中的形参赋值
属性
	1. value：请求参数中的名称
	2. required：请求参数中是否必须提供此参数，默认值是true，必须提供

<a href="anno/testRequestParam?name=haha">RequestParam</a>
@RequestMapping("/testRequestParam")
public String testRequestParam(@RequestParam(name="name") String username){
	System.out.println("执行了...");
	System.out.println(username);
	return "success";
}
	
	
RequestBody注解
作用：用于获取请求体的内容（注意：get方法不可以）
属性:
	required：是否必须有请求体，默认值是true

<form action="anno/testRequestBody" method="post">
	用户名: <input type="text" name="uname"><br>
	年龄: <input type="text" name="age"><br>
	<input type="submit" value="提交">
</form>

@RequestMapping("/testRequestBody")
public String testRequestBody(@RequestBody String body){
	System.out.println("执行了...");
	System.out.println(body);
	return "success";
}
	
	
PathVariable注解
作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符
属性
	1. value：指定url中的占位符名称
Restful风格的URL
	请求路径一样，可以根据不同的请求方式去执行后台的不同方法
	restful风格的URL优点
		1. 结构清晰
		2. 符合标准
		3. 易于理解
		4. 扩展方便

<a href="anno/testPathVariable/10">testPathVariable</a>
@RequestMapping(value="/testPathVariable/{sid}")
public String testPathVariable(@PathVariable(name="sid") String id){
	System.out.println("执行了...");
	System.out.println(id);
	return "success";
}

REST（英文： Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，比如 web 应用程序。
	HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，
	必须通过某种手段， 让服务器端发生“状态转化” （State Transfer）。而这种转化是建立在表现层之上的，所以
	就是 “表现层状态转化” 。具体说，就是 HTTP 协议里面，四个表示操作方式的动词： GET 、 POST 、 PUT、
	DELETE。它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源。
	restful 的示例：
		/account/1 HTTP GET ： 得到 id = 1 的 account
		/account/1 HTTP DELETE： 删除 id = 1 的 account
		/account/1 HTTP PUT： 更新 id = 1 的 account
		/account HTTP POST： 新增 account
HiddentHttpMethodFilter 
	由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、 PUT 等 method 并不支持， Spring3.0 添加了一个过滤器，
	HiddentHttpMethodFilter可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、 POST、 PUT与 DELETE 请求。

		
RequestHeader注解
作用：获取指定请求头的值
属性:
	value：请求头的名称


CookieValue注解
作用：用于获取指定cookie的名称的值
属性:
	value：cookie的名称
	
ModelAttribute注解
作用：
	该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。
	出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可
	以修饰有具体返回值的方法。
	出现在参数上，获取指定的数据给参数赋值。
属性：
	value：用于获取数据的 key。 key 可以是 POJO 的属性名称，也可以是 map 结构的 key。
应用场景：
	当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。
例如：
	我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数
	据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。

/**
 * ModelAttribute注解
 * @return
 */
@RequestMapping(value="/testModelAttribute")
public String testModelAttribute(@ModelAttribute("abc") User user){
	System.out.println("testModelAttribute执行了...");
	System.out.println(user);
	return "success";
}	
/**
 * 没有返回值的情况
 * @param uname
 * @param map
 */
@ModelAttribute
public void showUser(String uname, Map<String,User> map){
	System.out.println("showUser执行了...");
	// 通过用户查询数据库（模拟）
	User user = new User();
	user.setUname(uname);
	user.setAge(50);
	user.setDate(new Date());
	// 没有返回值，存到 map中，控制器通过在参数前加@ModelAttribute("abc")注解拿到map
	map.put("abc",user);
}
	
SessionAttributes注解
作用：用于多次执行控制器方法间的参数共享
属性：
	value：指定存入属性的名称

/**
 * SessionAttributes的注解
 * Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap
 * 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类
 * @param model
 * @return
 */
@RequestMapping(value="/testSessionAttributes")
public String testSessionAttributes(Model model){
	System.out.println("testSessionAttributes...");
	//跳转之前将数据保存到msg中，底层会存储到request域对象中${requestScope}
	model.addAttribute("msg","美美");
	return "success";
}

在jsp页面上，可以通过 ${ msg } 获取

// SessionAttributes注解作用在类上，把msg=美美存入到session域对中
@SessionAttributes(value={"msg"})
在jsp页面上，可以通过 ${sessionScope} 获取

/**
 * 获取值
 * @param modelMap
 * @return
 */
@RequestMapping(value="/getSessionAttributes")
public String getSessionAttributes(ModelMap modelMap){
	System.out.println("getSessionAttributes...");
	String msg = (String) modelMap.get("msg");
	System.out.println(msg);
	return "success";
}

/**
 * 清除
 * @param status
 * @return
 */
@RequestMapping(value="/delSessionAttributes")
public String delSessionAttributes(SessionStatus status){
	System.out.println("getSessionAttributes...");
	status.setComplete();
	return "success";
}



SpringMVC返回数据类型和响应数据类型

返回 String 类型的值
@RequestMapping("/testString")
public String testString(Model model){
	System.out.println("testString方法");
	// 模拟从数据库中查询出User对象
	User user = new User();
	user.setUsername("美美");
	user.setPassword("123");
	user.setAge(30);
	// model对象，底层会存储到request域对象中
	model.addAttribute("user",user);
	return "success";
}

没有返回值
/**
 * 没有返回值,RequestMapping中的值是什么，就返回该jsp
 * 这里默认返回 testVoid.jsp 没有这个页面会报404
 * @param model
 */
@RequestMapping("/testVoid")
public void testVoid(Model model){
	System.out.println("testString方法");
}

/**
 * 基于上面的情况，我们可以转发的别的页面，也可以直接响应数据
 * @param request
 * @param response
 * @throws Exception
 */
@@RequestMapping("/testVoid")
public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception {
	System.out.println("testVoid方法执行了...");
	// 编写请求转发的程序
	// request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response);

	// 重定向
	// response.sendRedirect(request.getContextPath()+"/index.jsp");

	// 设置中文乱码
	response.setCharacterEncoding("UTF-8");
	response.setContentType("text/html;charset=UTF-8");

	// 直接会进行响应
	response.getWriter().print("你好");

	return;
}

返回值是 ModelAndView
/**
 * 返回值是 ModelAndView
 * ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图
 * @param model
 * @return
 */
@RequestMapping("/testModelAndView")
public ModelAndView testModelAndView(Model model){
	System.out.println("testModelAndView方法");

	ModelAndView mv = new ModelAndView();

	// 模拟从数据库中查询出User对象
	User user = new User();
	user.setUsername("美美");
	user.setPassword("123");
	user.setAge(30);

	// 把user对象存到mv对象中，也会把user存入request对象
	mv.addObject("user",user);
	// 跳转到哪个页面，跳转前可以使用视图解析器
	mv.setViewName("success");
	return mv;
}

SpringMVC框架提供的转发和重定向(关键词)
/**
 * SpringMVC框架提供的转发和重定向
 * @param model
 * @return
 */
@RequestMapping("/testForwardOrRedirect")
public String testForwardOrRedirect(Model model){
	System.out.println("testForwardOrRedirect 方法");

	// return "forward:/WEB-INF/pages/success.jsp";
	return "redirect:/index.jsp";
}

模拟异步请求,响应json
/**
 * 模拟异步请求响应
 * 将请求体字符串封装为bean对象，需要jackson的jar包
 * @ResponseBody 将对象转为json响应到前端
 * @RequestBody 接收前端的请全体字符串转换为bean对象
 */
@RequestMapping("/testAjax")
public @ResponseBody User testAjax(@RequestBody User user){
	System.out.println("testAjax方法执行了...");
	// 客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中
	System.out.println(user);
	// 做响应，模拟查询数据库
	user.setUsername("haha");
	user.setAge(40);
	// 做响应
	return user;
}



文件上传
文件上传需要依赖commons-fileupload和commons-io
跨服务器上传需要依赖jersey-client和jersey-core

/**
 * 传统文件上传
 * @param request
 * @return
 * @throws Exception
 */
@RequestMapping("/fileupload1")
public String fileUpload1(HttpServletRequest request) throws Exception {
	System.out.println("文件上传");

	// 使用fileupload组件完成文件上传
	// 上传的位置
	String path = request.getSession().getServletContext().getRealPath("/uploads/");
	// 判断，该路径是否存在
	File file = new File(path);
	if(!file.exists()){
		// 创建该文件夹
		file.mkdirs();
	}
	// 解析request对象，获取上传文件项
	DiskFileItemFactory factory = new DiskFileItemFactory();
	ServletFileUpload upload = new ServletFileUpload(factory);
	// 解析request
	List<FileItem> items = upload.parseRequest(request);
	// 遍历
	for(FileItem item : items){
		// 进行判断，当前item对象是否是上传文件项
		if(item.isFormField()){
			// 说明普通表单向
		}else{
			// 说明上传文件项
			// 获取上传文件的名称
			String filename = item.getName();
			// 把文件的名称设置唯一值，uuid
			String uuid = UUID.randomUUID().toString().replace("-", "");
			filename = uuid+"_"+filename;
			// 完成文件上传
			item.write(new File(path,filename));
			// 删除临时文件
			item.delete();
		}
	}
	return "success";
}

使用SpringMVC进行文件上传，需要配置文件解析器对象
<!--配置文件解析器对象-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
	<property name="maxUploadSize" value="10485760" />
</bean>

/**
 * SpringMVC文件上传
 * 前端控制器将请求发给文件解析器，文件解析器拿到upload传给控制器
 * MultipartFile 参数名upload必须和前端input中的name相同
 * @return
 */
@RequestMapping("/fileupload2")
public String fileuoload2(HttpServletRequest request, MultipartFile upload) throws Exception {
	System.out.println("springmvc文件上传...");

	// 使用fileupload组件完成文件上传
	// 上传的位置
	String path = request.getSession().getServletContext().getRealPath("/uploads/");
	// 判断，该路径是否存在
	File file = new File(path);
	if(!file.exists()){
		// 创建该文件夹
		file.mkdirs();
	}

	// 说明上传文件项
	// 获取上传文件的名称
	String filename = upload.getOriginalFilename();
	// 把文件的名称设置唯一值，uuid
	String uuid = UUID.randomUUID().toString().replace("-", "");
	filename = uuid+"_"+filename;
	// 完成文件上传
	upload.transferTo(new File(path,filename));

	return "success";
}

服务器默认是只读的，如果要写入数据，需要设置tomcat的web.xml配置文件

/**
 * 跨服务器文件上传
 * 需要在tomcat服务器目录下conf/web.xml中配置，否则报 403
 *      <init-param>
 * 			<param-name>readonly</param-name>
 * 			<param-value>false</param-value>
 * 		</init-param>
 * @return
 */
@RequestMapping("/fileupload3")
public String fileuoload3(MultipartFile upload) throws Exception {
	System.out.println("跨服务器文件上传...");

	// 定义上传文件服务器路径
	String path = "http://localhost:9090/uploads/";

	// 获取上传文件的名称
	String filename = upload.getOriginalFilename();
	// 把文件的名称设置唯一值，uuid
	String uuid = UUID.randomUUID().toString().replace("-", "");
	filename = uuid+"_"+filename;

	// 创建客户端的对象
	Client client = Client.create();
	// 和图片服务器进行连接
	WebResource webResource = client.resource(path + filename);
	// 上传文件
	webResource.put(upload.getBytes());

	return "success";
}


异常处理
异常处理器需要实现HandlerExceptionResolver接口，重写resolveException方法
异常处理在服务端代码产生异常后，用于在页面友好提示，而不是显示大堆异常信息

自定义异常类
/**
 * @Author Figo
 * @Date 2019/12/5 23:03
 * 自定义异常类
 */
public class SysException extends Exception{

    // 存储提示信息的
    private String message;

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public SysException(String message) {
        this.message = message;
    }

}

/**
 * @Author Figo
 * @Date 2019/12/5 23:05
 * 异常处理器
 */
public class SysExceptionResolver implements HandlerExceptionResolver {

    /**
     * 处理异常业务逻辑，当控制器抛出异常后，会进入异常处理类执行
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @return
     */
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,
                                         Object handler, Exception ex) {
        // 获取到异常对象
        SysException e = null;
        if(ex instanceof SysException){
            e = (SysException)ex;
        }else{
            e = new SysException("系统正在维护....");
        }
        // 创建ModelAndView对象
        ModelAndView mv = new ModelAndView();
        mv.addObject("errorMsg",e.getMessage());
        mv.setViewName("error");
        return mv;
    }
}

在springmvc.xml中配置异常处理器
	<!--配置异常处理器-->
    <bean id="sysExceptionResolver" class="cn.figo.exception.SysExceptionResolver"/>

在控制器中抛出异常
@Controller
@RequestMapping("/user")
public class UserController {
    @RequestMapping("/testException")
    public String testException() throws SysException {
        System.out.println("testException执行了...");
        try {
            // 模拟异常
            int a = 10/0;
        } catch (Exception e) {
            // 打印异常信息
            e.printStackTrace();
            // 抛出自定义异常信息
            throw new SysException("查询所有用户出现错误了...");
        }
        return "success";
    }
}

拦截器
Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。
用户可以自己定义一些拦截器来实现特定的功能。
拦截器链（Interceptor Chain），拦截器链就是将拦截器按一定的顺序联结成一条链。
在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。
过滤器和拦截器的区别：
过滤器是 servlet 规范中的一部分， 任何 java web 工程都可以使用。
拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。
过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。
拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp， html,css,image 或者 js 是不会进行拦截的。
拦截器是 AOP 思想的具体应用。

在定义拦截器，需要实现HandlerInterceptor接口，重写preHandle、postHandle、afterCompletion方法
preHandle：预处理，在controller方法执行前执行。
	返回值true放行，执行下一个拦截器，如果没有，执行controller中的方法。
	返回值false不放行
postHandle：后处理方法，在controller方法执行后，success.jsp执行之前执行
afterCompletion：success.jsp页面执行后，该方法会执行

自定义拦截器，要求必须实现： HandlerInterceptor 接口。
/**
 * 自定义拦截器
 */
public class MyInterceptor1 implements HandlerInterceptor {

    /**
     * 预处理，controller方法执行前
     * return true 放行，执行下一个拦截器，如果没有，执行controller中的方法
     * return false不放行
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("MyInterceptor1执行了...前1111");
        // request.getRequestDispatcher("/WEB-INF/pages/error.jsp").forward(request,response);
        return true;
    }

    /**
     * 后处理方法，controller方法执行后，success.jsp执行之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("MyInterceptor1执行了...后1111");
        // request.getRequestDispatcher("/WEB-INF/pages/error.jsp").forward(request,response);
    }

    /**
     * success.jsp页面执行后，该方法会执行
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("MyInterceptor1执行了...最后1111");
    }

}

在springmvc.xml中配置拦截器
	<!--配置拦截器-->
    <mvc:interceptors>
        <!--配置拦截器-->
        <mvc:interceptor>
            <!--要拦截的具体的方法-->
            <mvc:mapping path="/user/*"/>
            <!--不要拦截的方法
            <mvc:exclude-mapping path=""/>
            -->
            <!--配置拦截器对象-->
            <bean class="cn.figo.interceptor.MyInterceptor1" />
        </mvc:interceptor>
    </mvc:interceptors>
	

	
分页插件pagehelper

依赖坐标
<dependency>
	<groupId>com.github.pagehelper</groupId>
	<artifactId>pagehelper</artifactId>
	<version>5.1.2</version>
</dependency>

在spring整合mybatis的sqlSessionFactory中加入分页插件
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
	<property name="dataSource" ref="dataSource"/>
	<!-- 传入PageHelper的插件 -->
	<property name="plugins">
		<array>
			<!-- 传入插件的对象 -->
			<bean class="com.github.pagehelper.PageInterceptor">
				<property name="properties">
					<props>
						<prop key="helperDialect">oracle</prop>
						<prop key="reasonable">true</prop>
					</props>
				</property>
			</bean>
		</array>
	</property>
</bean>

在service中真正执行dao查询的语句前加入分页
public List<Orders> findAll(int page, int size) throws Exception {

	//参数pageNum 是页码值   参数pageSize 代表是每页显示条数
	PageHelper.startPage(page, size);
	return ordersDao.findAll();
}

orders的实体类为
orderTimeStr、orderStatusStr、payTypeStr三个为展示字段，数据库中并没有
public class Orders {
    private String id;
    private String orderNum;
    private Date orderTime;
    private String orderTimeStr;
    private int orderStatus;
    private String orderStatusStr;
    private int peopleCount;
    private Product product;
    private List<Traveller> travellers;
    private Member member;
    private Integer payType;
    private String payTypeStr;
    private String orderDesc;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getOrderNum() {
        return orderNum;
    }

    public void setOrderNum(String orderNum) {
        this.orderNum = orderNum;
    }

    public Date getOrderTime() {
        return orderTime;
    }

    public void setOrderTime(Date orderTime) {
        this.orderTime = orderTime;
    }

    public String getOrderTimeStr() {
        if(orderTime!=null){
            orderTimeStr= DateUtils.date2String(orderTime,"yyyy-MM-dd HH:mm");
        }
        return orderTimeStr;
    }

    public void setOrderTimeStr(String orderTimeStr) {
        this.orderTimeStr = orderTimeStr;
    }

    public int getOrderStatus() {
        return orderStatus;
    }

    public void setOrderStatus(int orderStatus) {
        this.orderStatus = orderStatus;
    }

    public String getOrderStatusStr() {
        //订单状态(0 未支付 1 已支付)
        if(orderStatus==0){
            orderStatusStr="未支付";
        }else if(orderStatus==1){
            orderStatusStr="已支付";
        }
        return orderStatusStr;
    }

    public void setOrderStatusStr(String orderStatusStr) {
        this.orderStatusStr = orderStatusStr;
    }

    public int getPeopleCount() {
        return peopleCount;
    }

    public void setPeopleCount(int peopleCount) {
        this.peopleCount = peopleCount;
    }

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }

    public List<Traveller> getTravellers() {
        return travellers;
    }

    public void setTravellers(List<Traveller> travellers) {
        this.travellers = travellers;
    }

    public Member getMember() {
        return member;
    }

    public void setMember(Member member) {
        this.member = member;
    }

    public Integer getPayType() {
        return payType;
    }

    public void setPayType(Integer payType) {
        this.payType = payType;
    }

    public String getPayTypeStr() {
        //支付方式(0 支付宝 1 微信 2其它)
        if(payType==0){
            payTypeStr="支付宝";
        }else if(payType==1){
            payTypeStr="微信";
        }else if(payType==2){
            payTypeStr="其它";
        }
        return payTypeStr;
    }

    public void setPayTypeStr(String payTypeStr) {
        this.payTypeStr = payTypeStr;
    }

    public String getOrderDesc() {
        return orderDesc;
    }

    public void setOrderDesc(String orderDesc) {
        this.orderDesc = orderDesc;
    }
}

orders的查询方法需要product的一对一查询，需要用到ProductDao中的根据id查询一个实体的方法
public interface IOrdersDao {

    @Select("select * from orders")
    @Results({
            @Result(id=true,property = "id",column = "id"),
            @Result(property = "orderNum",column = "orderNum"),
            @Result(property = "orderTime",column = "orderTime"),
            @Result(property = "orderStatus",column = "orderStatus"),
            @Result(property = "peopleCount",column = "peopleCount"),
            @Result(property = "peopleCount",column = "peopleCount"),
            @Result(property = "payType",column = "payType"),
            @Result(property = "orderDesc",column = "orderDesc"),
            @Result(property = "product",column = "productId",javaType = Product.class,one = @One(select = "cn.figo.dao.IProductDao.findById")),
    })
    public List<Orders> findAll() throws Exception;
}

productDao中的方法
//查询所有的产品信息
@Select("select * from product")
public List<Product> findAll() throws Exception;

查询时需要提供参数
href="${pageContext.request.contextPath}/orders/findAll.do?page=1&pageSize=3"

controller为，需要使用pagehelper提供的PageInfo分页Bean
@RequestMapping("/findAll.do")
public ModelAndView findAll(@RequestParam(name = "page", required = true, defaultValue = "1") int page, 
							@RequestParam(name = "size", required = true, defaultValue = "3") int size) throws Exception {
	ModelAndView mv = new ModelAndView();
	List<Orders> ordersList = ordersService.findAll(page, size);
	//PageInfo就是一个分页Bean
	PageInfo pageInfo=new PageInfo(ordersList);
	mv.addObject("pageInfo",pageInfo);
	mv.setViewName("orders-page-list");
	return mv;
}

PageInfo中保存的具体的orders数据通过它的list属性获取pageInfo.list
然后就可以在jsp中取出需要的数据
<c:forEach items="${pageInfo.list}" var="orders">
	<tr>
		<td><input name="ids" type="checkbox"></td>
		<td>${orders.id }</td>
		<td>${orders.orderNum }</td>
		<td>${orders.product.productName }</td>
		<td>${orders.product.productPrice }</td>
		<td>${orders.orderTimeStr }</td>
		<td class="text-center">${orders.orderStatusStr }</td>
		<td class="text-center">
			<button type="button" class="btn bg-olive btn-xs">订单</button>
			<button type="button" class="btn bg-olive btn-xs" onclick="location.href='${pageContext.request.contextPath}/orders/findById.do?id=${orders.id}'">详情</button>
			<button type="button" class="btn bg-olive btn-xs">编辑</button>
		</td>
	</tr>
</c:forEach>

分页栏的请求参数设置
<div class="box-tools pull-right">
	<ul class="pagination">
		<li>
			<a href="${pageContext.request.contextPath}/orders/findAll.do?page=1&size=${pageInfo.pageSize}"
			   aria-label="Previous">首页</a>
		</li>
		<li>
			<a href="${pageContext.request.contextPath}/orders/findAll.do?page=${pageInfo.pageNum-1}&size=${pageInfo.pageSize}">上一页</a>
		</li>
		<c:forEach begin="1" end="${pageInfo.pages}" var="pageNum">
			<li>
				<a href="${pageContext.request.contextPath}/orders/findAll.do?page=${pageNum}&size=${pageInfo.pageSize}">${pageNum}</a>
			</li>
		</c:forEach>
		<li>
			<a href="${pageContext.request.contextPath}/orders/findAll.do?page=${pageInfo.pageNum+1}&size=${pageInfo.pageSize}">下一页</a>
		</li>
		<li>
			<a href="${pageContext.request.contextPath}/orders/findAll.do?page=${pageInfo.pages}&size=${pageInfo.pageSize}"
			   aria-label="Next">尾页</a>
		</li>
	</ul>
</div>



springSecurity
配置文件
<!--使用springSecurity默认的登录页面-->
<security:http auto-config="true" use-expressions="false" >
	<!-- 配置资料连接，表示任意路径都需要ROLE_USER权限 -->
	<security:intercept-url pattern="/**" access="ROLE_USER" />
</security:http>

<security:authentication-manager>
	<security:authentication-provider>
		<!--配置了两个用户名和密码可以登录-->
		<security:user-service>
			<security:user name="user" password="{noop}user"
						   authorities="ROLE_USER" />
			<security:user name="admin" password="{noop}admin"
						   authorities="ROLE_ADMIN" />
		</security:user-service>
	</security:authentication-provider>
</security:authentication-manager>

web.xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring-security.xml</param-value>
</context-param>
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

不使用springSecurity默认的登录、成功、失败页面
<!-- 配置不过滤的资源（静态资源及登录相关） -->
<security:http security="none" pattern="/login.html" />
<security:http security="none" pattern="/failer.html" />
<security:http auto-config="true" use-expressions="false" >
	<!-- 配置资料连接，表示任意路径都需要ROLE_USER权限 -->
	<security:intercept-url pattern="/**" access="ROLE_USER" />
	<!-- 自定义登陆页面，login-page 自定义登陆页面 authentication-failure-url 用户权限校验失败之后才会跳转到这个页面，如果数据库中没有这个用户则不会跳转到这个页面。
		default-target-url 登陆成功后跳转的页面。 注：登陆页面用户名固定 username，密码 password，action:login -->
	<security:form-login login-page="/login.html"
						 login-processing-url="/login" username-parameter="username"
						 password-parameter="password" authentication-failure-url="/failer.html"
						 default-target-url="/success.html" authentication-success-forward-url="/success.html"
	/>

	<!-- 关闭CSRF,默认是开启的 -->
	<security:csrf disabled="true" />
</security:http>
<security:authentication-manager>
	<security:authentication-provider>
		<security:user-service>
			<security:user name="user" password="{noop}user"
						   authorities="ROLE_USER" />
			<security:user name="admin" password="{noop}admin"
						   authorities="ROLE_ADMIN" />
		</security:user-service>
	</security:authentication-provider>
</security:authentication-manager>


使用springSecurity从数据库查询用户和角色进行登录
UserInfo是数据库中的users对应的实体类
User是springSecurity中的UserDetails的类，可以配合springSecurity进行登录判断

@Service("userService")
@Transactional
public class UserServiceImpl implements IUserService{

    @Autowired
    private IUserDao userDao;

    /**
     * 查询所有user
     * @return
     * @throws Exception
     */
    @Override
    public List<UserInfo> findAll() throws Exception {
        return userDao.findAll();
    }

    /**
     * 登录时，根据用户名查询用户及其角色信息
     * @param username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserInfo userInfo = null;
        try {
            userInfo = userDao.findByUsername(username);
        } catch (Exception e) {
            e.printStackTrace();
        }
        // 处理自己的用户对象封装成UserDetails
        // User user=new User(userInfo.getUsername(),"{noop}"+userInfo.getPassword(),getAuthority(userInfo.getRoles()));
        // 通过用户状态、角色信息控制用户是否可成功登录
        User user = new User(userInfo.getUsername(), userInfo.getPassword(),userInfo.getStatus() == 0 ? false : true,
                true, true, true, getAuthority(userInfo.getRoles()));
        return user;
    }

    /**
     * 作用就是返回一个List集合，集合中装入的是springSecurity需要的角色描述
     * @param roles
     * @return
     */
    public List<SimpleGrantedAuthority> getAuthority(List<Role> roles) {

        List<SimpleGrantedAuthority> list = new ArrayList<>();
        for (Role role : roles) {
            list.add(new SimpleGrantedAuthority("ROLE_" + role.getRoleName()));
        }
        return list;
    }

}

在springSecurity中配置
<!-- 配置不拦截的资源 -->
<security:http pattern="/login.jsp" security="none"/>
<security:http pattern="/failer.jsp" security="none"/>
<security:http pattern="/css/**" security="none"/>
<security:http pattern="/img/**" security="none"/>
<security:http pattern="/plugins/**" security="none"/>
<!--
	配置具体的规则
	auto-config="true"	不用自己编写登录的页面，框架提供默认登录页面
	use-expressions="false"	是否使用SPEL表达式（没学习过）
-->
<security:http auto-config="true" use-expressions="false">
	<!-- 配置具体的拦截的规则 pattern="请求路径的规则" access="访问系统的人，必须有ROLE_USER的角色" -->
	<security:intercept-url pattern="/**" access="ROLE_USER,ROLE_ADMIN"/>

	<!-- 定义跳转的具体的页面 -->
	<security:form-login
			login-page="/login.jsp"
			login-processing-url="/login.do"
			default-target-url="/index.jsp"
			authentication-failure-url="/failer.jsp"
			authentication-success-forward-url="/pages/main.jsp"
	/>

	<!-- 关闭跨域请求 -->
	<security:csrf disabled="true"/>
	<!-- 退出 -->
	<security:logout invalidate-session="true" logout-url="/logout.do" logout-success-url="/login.jsp" />

</security:http>

<!-- 切换成数据库中的用户名和密码 -->
<security:authentication-manager>
	<security:authentication-provider user-service-ref="userService">
		<!-- 配置加密的方式-->
		<security:password-encoder ref="passwordEncoder"/>
	</security:authentication-provider>
</security:authentication-manager>

<!-- 配置加密类 -->
<bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/>


权限控制

<!--开启方法级别的权限控制（使用 jsr250）-->
<security:global-method-security jsr250-annotations="enabled"></security:global-method-security>

然后就可以在controller中添加权限，只有ADMIN角色才可以访问该方法
//查询全部产品
@RequestMapping("/findAll.do")
@RolesAllowed("ADMIN")
public ModelAndView findAll() throws Exception {
	ModelAndView mv = new ModelAndView();
	List<Product> ps = productService.findAll();
	mv.addObject("productList", ps);
	mv.setViewName("product-list");
	return mv;
}

<!--开启 secured 注解-->
secured-annotations="enabled"

在controller中添加权限，只有ADMIN角色才可以访问该方法
//查询全部订单
@RequestMapping("/findAll.do")
@Secured("ROLE_ADMIN")
public ModelAndView findAll(@RequestParam(name = "page", required = true, defaultValue = "1") int page,
							@RequestParam(name = "size", required = true, defaultValue = "3") int size) throws Exception {
	ModelAndView mv = new ModelAndView();
	List<Orders> ordersList = ordersService.findAll(page, size);
	//PageInfo就是一个分页Bean
	PageInfo pageInfo=new PageInfo(ordersList);
	mv.addObject("pageInfo",pageInfo);
	mv.setViewName("orders-page-list");
	return mv;
}

Secured必须加ROLE_前缀，这是在spring-security.xml中定义的，而RolesAllowed不需要加前缀
<security:intercept-url pattern="/**" access="ROLE_USER,ROLE_ADMIN"/>

<!--开启 PreAuthorize 注解 ,在方法调用之前,基于表达式的计算结果来限制对方法的访问-->
pre-post-annotations="enabled"
/**
 * 展示所有用户信息
 * @return
 * @throws Exception
 */
@RequestMapping("/findAll.do")
// 只有 ROLE_ADMIN 角色可以访问
@PreAuthorize("hasRole('ROLE_ADMIN')")
public ModelAndView findAll() throws Exception {
	ModelAndView mv = new ModelAndView();
	List<UserInfo> userList = userService.findAll();
	mv.addObject("userList", userList);
	mv.setViewName("user-list");
	return mv;
}

/**
 * 用户添加
 * @param userInfo
 * @return
 * @throws Exception
 */
@RequestMapping("/save.do")
// 只有 tom 这个用户可以访问
@PreAuthorize("authentication.principal.username == 'tom'")
public String save(UserInfo userInfo) throws Exception {
	userService.save(userInfo);
	return "redirect:findAll.do";
}


在jsp页面中我们可以使用spring security提供的权限标签来进行权限控制
<%@taglib uri="http://www.springframework.org/security/tags" prefix="security"%>

authentication
<security:authentication property="" htmlEscape="" scope="" var=""/>

property： 只允许指定Authentication所拥有的属性，可以进行属性的级联获取，如“principle.username”，
	不允许直接通过方法进行调用
htmlEscape：表示是否需要将html进行转义。默认为true。
scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥
	有的作用范围都进行进行指定
var： 用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存
	放，默认是存放在pageConext中

在页面中显示当前用户名
<security:authentication property="principal.username"></security:authentication>	
	
	
authorize
authorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示
<security:authorize access="" method="" url="" var=""></security:authorize>
access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限
method：method属性是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，
	method的默认值为GET，可选值为http请求的7种方法
url：url表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容
var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中

ADMIN角色才可以显示该标签
<security:authorize access="hasRole('ADMIN')">
	<a href="${pageContext.request.contextPath}/user/findAll.do"> <i
		class="fa fa-circle-o"></i> 用户管理
	</a>
</security:authorize>


AOP日志

package cn.figo.controller;
import cn.figo.domain.SysLog;
import cn.figo.service.ISysLogService;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.RequestMapping;
import javax.servlet.http.HttpServletRequest;
import java.lang.reflect.Method;
import java.util.Date;

/**
 * @Author Figo
 * @Date 2019/12/17 22:14
 */
@Component
@Aspect
public class LogAop {

    // request对象需要 在web.xml中配置监听器 org.springframework.web.context.request.RequestContextListener
    @Autowired
    private HttpServletRequest request;

    @Autowired
    private ISysLogService sysLogService;

    //开始时间
    private Date visitTime;
    //访问的类
    private Class clazz;
    //访问的方法
    private Method method;

    /**
     * 前置通知  主要是获取开始时间，执行的类是哪一个，执行的是哪一个方法
     * @param jp
     * @throws NoSuchMethodException
     */
    @Before("execution(* cn.figo.controller.*.*(..))")
    public void doBefore(JoinPoint jp) throws NoSuchMethodException {
        //当前时间就是开始访问的时间
        visitTime = new Date();
        //具体要访问的类
        clazz = jp.getTarget().getClass();
        //获取访问的方法的名称
        String methodName = jp.getSignature().getName();

        //获取访问的方法的参数
        Object[] args = jp.getArgs();
        //获取具体执行的方法的Method对象
        if (args == null || args.length == 0) {
            //只能获取无参数的方法
            method = clazz.getMethod(methodName);
        } else {
            Class[] classArgs = new Class[args.length];
            for (int i = 0; i < args.length; i++) {
                classArgs[i] = args[i].getClass();
            }
            clazz.getMethod(methodName, classArgs);
        }
    }

    /**
     * 后置通知
     * @param jp
     * @throws Exception
     */
    @After("execution(* cn.figo.controller.*.*(..))")
    public void doAfter(JoinPoint jp) throws Exception {
        //获取访问的时长
        long time = new Date().getTime() - visitTime.getTime();

        //获取url = 类上的路径 + 方法上的路径
        String url = "";
        if (clazz != null && method != null && clazz != LogAop.class) {
            //1.获取类上的@RequestMapping("/orders")
            RequestMapping classAnnotation = (RequestMapping) clazz.getAnnotation(RequestMapping.class);
            if (classAnnotation != null) {
                String[] classValue = classAnnotation.value();
                //2.获取方法上的@RequestMapping(xxx)
                RequestMapping methodAnnotation = method.getAnnotation(RequestMapping.class);
                if (methodAnnotation != null) {
                    String[] methodValue = methodAnnotation.value();
                    url = classValue[0] + methodValue[0];

                    //获取访问的ip
                    String ip = request.getRemoteAddr();

                    //获取当前操作的用户，可以通过securityContext获取，也可以从request.getSession中获取
                    //从上下文中获了当前登录的用户
                    SecurityContext context = SecurityContextHolder.getContext();
                    // SecurityContext context = request.getSession().getAttribute("SPRING_SECURITY_CONTEXT");
                    User user = (User) context.getAuthentication().getPrincipal();
                    String username = user.getUsername();



                    //将日志相关信息封装到SysLog对象
                    SysLog sysLog = new SysLog();
                    sysLog.setExecutionTime(time);
                    sysLog.setIp(ip);
                    sysLog.setMethod("[类名] " + clazz.getName() + "[方法名] " + method.getName());
                    sysLog.setUrl(url);
                    sysLog.setUsername(username);
                    sysLog.setVisitTime(visitTime);

                    //调用Service完成操作
                    sysLogService.save(sysLog);
                }
            }
        }

    }
}

@Service
@Transactional
public class SysLogServiceImpl implements ISysLogService {

    @Autowired
    private ISysLogDao sysLogDao;

    @Override
    public List<SysLog> findAll() throws Exception {
        return sysLogDao.findAll();
    }

    @Override
    public void save(SysLog sysLog) throws Exception {
        sysLogDao.save(sysLog);
    }
}

public interface ISysLogDao {

    @Insert("insert into syslog(visitTime,username,ip,url,executionTime,method) values(#{visitTime},#{username},#{ip},#{url},#{executionTime},#{method})")
    public void save(SysLog sysLog) throws Exception;

    @Select("select * from sysLog")
    List<SysLog> findAll() throws Exception;
}